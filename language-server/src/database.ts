export enum DBAllowSymbol
{
    None = 0,
    All = ~0,

    Properties = 1 << 0,
    Functions = 1 << 1,
    Mixins = 1 << 2,
    Types = 1 << 3,

    PropertiesAndFunctions = Properties | Functions,
    FunctionsAndMixins = Functions | Mixins,
};

export function AllowsFunctions(allowSymbol : DBAllowSymbol)
{
    return (allowSymbol & DBAllowSymbol.Functions) != 0;
}

export function AllowsProperties(allowSymbol : DBAllowSymbol)
{
    return (allowSymbol & DBAllowSymbol.Properties) != 0;
}

export function AllowsTypes(allowSymbol : DBAllowSymbol)
{
    return (allowSymbol & DBAllowSymbol.Types) != 0;
}

export function FilterAllowsSymbol(symbol : DBSymbol, allowSymbol : DBAllowSymbol) : boolean
{
    if (symbol instanceof DBProperty)
    {
        if ((allowSymbol & DBAllowSymbol.Properties) != 0)
            return true;
    }
    else if (symbol instanceof DBMethod)
    {
        if (symbol.isMixin)
        {
            if ((allowSymbol & DBAllowSymbol.Mixins) != 0)
                return true;
        }
        else
        {
            if ((allowSymbol & DBAllowSymbol.Functions) != 0)
                return true;
        }
    }
    else if (symbol instanceof DBType)
    {
        if ((allowSymbol & DBAllowSymbol.Types) != 0)
            return true;
    }

    return false;
}

export enum DBTypeClassification
{
    Unknown,
    Other,
    Component,
    Actor,
    Struct,
    Event,
    Delegate,
    Primitive
};

export interface DBSymbol
{
    name : string;
    containingType : DBType;
    namespace : DBNamespace;
    keywords : Array<string>;
    declaredModule : string | null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null;
};

export interface DBAuxiliarySymbol
{
    symbol_name : string;
    container_type : string;
};

export class DBProperty implements DBSymbol
{
    name : string;
    typename : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isNoEdit : boolean = false;
    isEditOnly : boolean = false;
    isAutoGenerated : boolean = false;
    isLiteralAsset : boolean = false;

    accessSpecifier : DBAccessSpecifier = null;
    declaredModule : string | null;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    containingType : DBType = null;
    namespace : DBNamespace = null;
    keywords : Array<string> = null;

    isUProperty : boolean = false;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    fromJSON(name : string, input : any)
    {
        this.name = name;
        this.typename = input[0];
        this.isProtected = false;
        this.isPrivate = false;
        this.isNoEdit = false;
        this.isEditOnly = false;

        let flags : number = 0;
        for (let i = 1; i < input.length; ++i)
        {
            if (typeof input[i] == 'string')
            {
                if (input[i] == "NoEdit")
                    flags |= 1;
                else if (input[i] == "EditOnly")
                    flags |= 2;
                else
                    this.documentation = FormatDocumentationComment(input[i]);
            }
            else if (typeof input[i] == 'number')
            {
                flags = input[i];
            }
        }

        if (flags & 0x1)
            this.isNoEdit = true;
        if (flags & 0x2)
            this.isEditOnly = true;
        if (flags & 0x4)
            this.isProtected = true;
    }

    format(prefix : string = null) : string
    {
        let str : string = "";
        if (this.isProtected)
            str += "protected ";
        if (this.isPrivate)
            str += "private ";
        str += this.typename;
        str += " ";
        if (prefix)
            str += prefix;
        str += this.name;
        return str;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBProperty
    {
        let inst = new DBProperty();
        inst.name = this.name;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export class DBArg
{
    name : string | null;
    typename : string;
    defaultvalue : string | null;

    init(typename : string, name : string, defaultvalue : string = "") : DBArg
    {
        this.name = name;
        this.typename = typename;
        if (defaultvalue)
            this.defaultvalue = defaultvalue;
        return this;
    }

    fromJSON(input : any)
    {
        this.name = 'name' in input ? input['name'] : null;
        this.typename = input['type'];
        this.defaultvalue = 'default' in input ? input['default'] : null;
    }

    format(overrideType : string = null) : string
    {
        let decl = this.typename;
        if (overrideType)
            decl = overrideType;

        if (this.name != null)
            decl += " " + this.name;
        if (this.defaultvalue != null)
            decl += " = " + this.defaultvalue;
        return decl;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBArg
    {
        let inst = new DBArg();
        inst.name = this.name;
        inst.defaultvalue = this.defaultvalue;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export enum DBMethodAnnotation
{
    None,
    IsHexColor,
    IsLinearColor,
};

export class DBMethod implements DBSymbol
{
    name : string;
    returnType : string;
    args : Array<DBArg>;
    argumentStr : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isConstructor : boolean = false;
    isBlueprintEvent : boolean = false;
    isCallable : boolean = true;
    isBlueprintOverride : boolean = false;
    isConst : boolean = false;
    isFinal : boolean = false;
    isProperty : boolean = false;
    isOverride : boolean = false;
    isDefaultsOnly : boolean = false;
    isLocal : boolean = false;
    id : number = NextMethodId++;
    containingType : DBType = null;
    namespace : DBNamespace = null;
    keywords : Array<string> = null;
    isAutoGenerated : boolean = false;
    isMixin : boolean = false;
    accessSpecifier : DBAccessSpecifier = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;
    determinesOutputTypeArgumentIndex : number = -1;

    isUFunction : boolean = false;
    unrealName : string | null = null;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    hasSuperCall : boolean = false;
    isEmpty : boolean = false;

    isDelegateBindFunction : boolean = false;
    delegateBindType : string = null;
    delegateObjectParam : number = -1;
    delegateFunctionParam : number = -1;
    delegateWildcardParam : number = -1;

    methodAnnotation : DBMethodAnnotation = DBMethodAnnotation.None;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBMethod
    {
        let inst = new DBMethod();
        inst.name = this.name;
        inst.returnType = ReplaceTemplateType(this.returnType, templateTypes, actualTypes);
        inst.argumentStr = this.argumentStr;
        inst.documentation = this.documentation;
        inst.isProtected = this.isProtected;
        inst.isPrivate = this.isPrivate;
        inst.isConstructor = this.isConstructor;
        inst.isBlueprintEvent = this.isBlueprintEvent;
        inst.isCallable = this.isCallable;
        inst.isBlueprintOverride = this.isBlueprintOverride;
        inst.isConst = this.isConst;
        inst.isProperty = this.isProperty;
        inst.isDefaultsOnly = this.isDefaultsOnly;
        inst.determinesOutputTypeArgumentIndex = this.determinesOutputTypeArgumentIndex;

        inst.args = [];
        for(let argval of this.args)
            inst.args.push(argval.createTemplateInstance(templateTypes, actualTypes));
        return inst;
    }

    fromJSON(input : any)
    {
        this.name = input.name;

        if ('return' in input)
            this.returnType = input['return'];
        else
            this.returnType = 'void';

        this.args = new Array<DBArg>();
        if ('args' in input)
        {
            for (let argDesc of input['args'])
            {
                let arg = new DBArg;
                arg.fromJSON(argDesc);

                this.args.push(arg);
            }
        }

        if ('doc' in input)
            this.documentation = FormatDocumentationComment(input['doc']);
        else
            this.documentation = null;

        if ('isConstructor' in input)
            this.isConstructor = input['isConstructor'];
        else
            this.isConstructor = false;

        if ('callable' in input)
            this.isCallable = input['callable'];
        else
            this.isCallable = true;

        if ('const' in input)
            this.isConst = input['const'];
        else
            this.isConst = false;

        if ('event' in input)
            this.isBlueprintEvent = input['event'];
        else
            this.isBlueprintEvent = false;

        if ('isProperty' in input)
            this.isProperty = input['isProperty'];
        else
            this.isProperty = true;

        if ('protected' in input)
            this.isProtected = input['protected'];
        else
            this.isProtected = false;

        if ('defaultsonly' in input)
            this.isDefaultsOnly = input['defaultsonly'];

        if ('keywords' in input)
            this.keywords = input['keywords'];

        if ('outputTypeIndex' in input)
            this.determinesOutputTypeArgumentIndex = input['outputTypeIndex'];

        if ('ufunction' in input)
        {
            this.isUFunction = input['ufunction'];
            if ('unrealname' in input)
                this.unrealName = input['unrealname'];
        }

        if ('meta' in input)
        {
            if (!this.macroMeta)
                this.macroMeta = new Map<string, string>();
            for (let metaSpec in input['meta'])
                this.macroMeta.set(metaSpec.toLowerCase(), input['meta'][metaSpec]);
            this.cacheDelegateMeta();
        }
    }

    cacheDelegateMeta()
    {
        if (!this.macroMeta)
            return;

        if (this.macroMeta.has("delegatefunctionparam")
            && this.macroMeta.has("delegateobjectparam")
            && this.macroMeta.has("delegatebindtype"))
        {
            this.isDelegateBindFunction = true;
            this.delegateBindType = this.macroMeta.get("delegatebindtype");

            let functionParam = this.macroMeta.get("delegatefunctionparam");
            let objectParam = this.macroMeta.get("delegateobjectparam");
            let wildcardParam = this.macroMeta.get("delegatewildcardparam");

            for (let i = 0, count = this.args.length; i < count; ++i)
            {
                if (this.args[i].name == objectParam)
                    this.delegateObjectParam = i;
                else if (this.args[i].name == functionParam)
                    this.delegateFunctionParam = i;
                else if (wildcardParam && this.args[i].name == wildcardParam)
                    this.delegateWildcardParam = i;
            }

        }
    }

    format(prefix : string = null, skipFirstArg = false, skipReturn = false, replaceName : string = null, determineType : DBType = null) : string
    {
        let decl : string = "";
        if (!skipReturn)
        {
            if (determineType)
                decl += this.applyDeterminesOutputType(this.returnType, determineType).name + " ";
            else if (this.determinesOutputTypeArgumentIndex != -1)
                decl += "auto ";
            else
                decl += this.returnType + " ";
        }
        if(prefix != null)
            decl += prefix;
        if (replaceName)
            decl += replaceName + "(";
        else
            decl += this.name + "(";
        let firstArg = true;
        if (this.argumentStr)
        {
            let argStr = this.argumentStr;
            if (skipFirstArg)
            {
                let cPos = argStr.search(",");
                if(cPos != -1)
                    argStr = argStr.substr(cPos+1).trim();
                else
                    argStr = "";
            }
            decl += argStr;
        }
        else if(this.args)
        {
            for(let i = 0; i < this.args.length; ++i)
            {
                if (skipFirstArg && i == 0)
                    continue;
                let argDecl = this.args[i].format();
                if (determineType && this.determinesOutputTypeArgumentIndex == i)
                    argDecl = this.args[i].format(this.applyDeterminesOutputType(this.args[i].typename, determineType).name);
                if (i > 1 || (!skipFirstArg && i > 0))
                    decl += ", ";
                decl += argDecl;
            }
        }
        decl += ")";
        if (this.isConst)
            decl += " const";
        if (this.isProperty && this.declaredModule)
            decl += " property";
        return decl;
    }

    // Get documentation either from this function or from the
    // first parent function we're overriding
    findAvailableDocumentation(includeParent = true, includeType = true) : string
    {
        if (this.documentation)
            return this.documentation;
        // Use the parent function's documentation
        if (this.containingType && includeParent)
        {
            for (let checktype of this.containingType.getInheritanceTypes())
            {
                let parentFunc = checktype.findFirstSymbol(this.name, DBAllowSymbol.Functions);
                if (parentFunc && parentFunc instanceof DBMethod && parentFunc.documentation)
                    return parentFunc.documentation;
            }
        }
        // Use the type's documentation for constructors
        if (this.isConstructor && includeType)
        {
            let dbReturn = LookupType(this.namespace, this.returnType);
            if (dbReturn && dbReturn instanceof DBType && dbReturn.documentation)
                return dbReturn.documentation;
        }
        return null;
    }

    getUnrealName() : string
    {
        if (this.unrealName)
            return this.unrealName;
        else
            return this.name;
    }

    hasMetaData(meta : string) : boolean
    {
        if (!this.macroMeta)
            return false;
        return this.macroMeta.has(meta.toLowerCase());
    }

    getRequiredArgumentCount() : number
    {
        if (!this.args)
            return 0;
        for (let i = 0, argCount = this.args.length; i < argCount; ++i)
        {
            if (this.args[i].defaultvalue)
                return i;
        }
        return this.args.length;
    }

    isSignatureEqual(otherFunc : DBMethod) : boolean
    {
        if ((!!this.args) != (!!otherFunc.args))
            return false;

        if (this.args)
        {
            if (this.args.length != otherFunc.args.length)
                return false;
            for (let i = 0, argCount = this.args.length; i < argCount; ++i)
            {
                if (this.args[i].typename != otherFunc.args[i].typename)
                    return false;
            }
        }

        if (this.returnType != otherFunc.returnType)
            return false;

        return true;
    }

    applyDeterminesOutputType(originalType : string, determineType : DBType) : DBType
    {
        let resultType = LookupType(this.namespace, originalType);
        if (!resultType)
            return resultType;
        if (!determineType)
            return resultType;

        if (determineType.isTemplateInstantiation)
        {
            let foundSubType = false;
            for (let subTypeName of determineType.templateSubTypes)
            {
                let subType = LookupType(this.namespace, subTypeName);
                if (!subType)
                    continue;
                if (subType.isValueType())
                    continue;

                foundSubType = true;
                determineType = subType;
                break;
            }

            if (!foundSubType)
                return resultType;
        }

        if (determineType.isValueType())
            return resultType;

        if (determineType.name == "UClass")
            return resultType;

        if (resultType.isTemplateInstantiation)
        {
            let replacedAny = false;
            let newDeclaration = resultType.templateBaseType + "<";
            for (let i = 0, Count = resultType.templateSubTypes.length; i < Count; ++i)
            {
                if (i != 0)
                    newDeclaration += ",";

                let subType = LookupType(this.namespace, resultType.templateSubTypes[i]);
                if (subType && !subType.isValueType() && determineType.inheritsFrom(subType.name) && !replacedAny)
                {
                    newDeclaration += TransferTypeQualifiers(
                        resultType.templateSubTypes[i],
                        determineType.getQualifiedTypenameInNamespace(this.namespace)
                    );
                    replacedAny = true;
                }
                else
                {
                    newDeclaration += resultType.templateSubTypes[i];
                }
            }

            if (replacedAny)
            {
                newDeclaration += ">";
                let newType = LookupType(this.namespace, newDeclaration);
                if (newType)
                    return newType;
            }
        }

        if (resultType.isValueType())
            return resultType;

        if (!determineType.inheritsFrom(resultType.name))
            return resultType;

        return determineType;
    }
};

export class DBType implements DBSymbol
{
    typeid : number = -1;
    name : string;
    supertype : string;
    unrealsuper : string;
    documentation : string;
    namespace : DBNamespace;

    isStruct : boolean;
    isEnum : boolean;
    isDelegate : boolean = false;
    isEvent : boolean = false;
    isPrimitive : boolean = false;
    isTemplateInstantiation : boolean = false;
    templateBaseType : string = null;

    classification : DBTypeClassification = DBTypeClassification.Unknown;
    acccessSpecifiers : Array<DBAccessSpecifier> = null;

    keywords : Array<string> = null;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    delegateArgs : Array<DBArg> = null;
    delegateReturn : string = null;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    templateSubTypes : Array<string>;

    symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
    symbolsByPrefix = new Map<string, Array<DBSymbol>>();

    containingType : DBType = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    createTemplateInstance(actualTypes : Array<string>) : DBType
    {
        if (actualTypes.length != this.templateSubTypes.length)
            return null;

        let inst = new DBType();
        inst.name = this.name;
        inst.supertype = this.supertype;
        inst.isEnum = this.isEnum;
        inst.declaredModule = this.declaredModule;
        inst.moduleOffset = this.moduleOffset;
        inst.moduleOffsetEnd = this.moduleOffsetEnd;
        inst.isTemplateInstantiation = true;
        inst.templateSubTypes = actualTypes;
        inst.templateBaseType = this.name;

        let baseType = this;
        this.forEachSymbol(function (sym : DBSymbol)
        {
            if (sym instanceof DBProperty)
            {
                let newProp = sym.createTemplateInstance(baseType.templateSubTypes, actualTypes);
                inst.addSymbol(newProp);
            }
            else if (sym instanceof DBMethod)
            {
                let newMethod = sym.createTemplateInstance(baseType.templateSubTypes, actualTypes);
                inst.addSymbol(newMethod);
            }
        });

        return inst;
    }

    initEmpty(name : string) : DBType
    {
        this.name = name;
        return this;
    }

    fromJSON(name : string, input : any)
    {
        this.name = name;
        for (let key in input.properties)
        {
            let prop = new DBProperty();
            prop.fromJSON(key, input.properties[key]);
            this.addSymbol(prop);
        }
        for (let key in input.methods)
        {
            let func = new DBMethod();
            func.fromJSON(input.methods[key]);
            this.addSymbol(func);
        }

        if ('subtypes' in input)
        {
            this.templateSubTypes = new Array<string>();
            for(let subtype of input['subtypes'])
            {
                this.templateSubTypes.push(subtype);
            }
        }

        if ('supertype' in input)
        {
            this.unrealsuper = input['supertype'];
        }

        if ('inherits' in input)
        {
            this.supertype = input['inherits'];
        }

        if ('doc' in input)
            this.documentation = FormatDocumentationComment(input['doc']);
        else
            this.documentation = null;

        if ('keywords' in input)
            this.keywords = input['keywords'];

        if ('isStruct' in input)
            this.isStruct = input['isStruct'];
        else
            this.isStruct = false;

        if ('isEnum' in input)
            this.isEnum = input['isEnum'];
        else
            this.isEnum = false;

        let delegateSignatureMethod : DBSymbol = null;
        if ('isEvent' in input)
        {
            this.isEvent = input['isEvent'];
            if (this.isEvent)
                delegateSignatureMethod = this.findFirstSymbol("Broadcast");
        }
        else
        {
            delegateSignatureMethod = this.findFirstSymbol("Broadcast");
            this.isEvent = delegateSignatureMethod != null;
        }

        if ('isDelegate' in input)
        {
            this.isDelegate = input['isDelegate'];
            if (this.isDelegate)
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
        }
        else
        {
            if (!this.isEvent)
            {
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
                this.isDelegate = delegateSignatureMethod != null;
            }
            else
            {
                this.isDelegate = false;
            }
        }

        if (delegateSignatureMethod != null && delegateSignatureMethod instanceof DBMethod)
        {
            // Detect the signature for the delegate from the Broadcast or ExecuteIfBound methods
            this.delegateArgs = delegateSignatureMethod.args;
            this.delegateReturn = delegateSignatureMethod.returnType;

            // Mark the Add/Bind/Unbind functions so diagnostics can see them
            let bindFuncs: DBSymbol[] = [];
            if (this.isEvent)
                bindFuncs = [this.findFirstSymbol("AddUFunction"), this.findFirstSymbol("Unbind")];
            else
                bindFuncs = [this.findFirstSymbol("BindUFunction")];

            bindFuncs.forEach((bindFunc: DBSymbol) => {
                if (bindFunc instanceof DBMethod)
                {
                    bindFunc.isDelegateBindFunction = true;
                    bindFunc.delegateBindType = this.name;
                    bindFunc.delegateObjectParam = 0;
                    bindFunc.delegateFunctionParam = 1;
                }
            });
        }
    }

    getDisplayName() : string
    {
        return this.name;
    }

    isTemplateType() : boolean
    {
        return this.templateSubTypes && this.templateSubTypes.length != 0;
    }

    getSuperType() : DBType
    {
        if (!this.supertype)
            return null;
        return LookupType(this.namespace, this.supertype);
    }

    equalsTypename(typename : string) : boolean
    {
        if (typename == this.name)
            return true;
        let cleaned = CleanTypeName(typename);
        if (cleaned == this.name)
            return true;
        return false;
    }

    isUnrealType() : boolean
    {
        return !this.declaredModule;
    }

    hasExtendTypes() : boolean
    {
        if(this.supertype)
            return true;
        return false;
    }

    isShadowingNamespace() : boolean
    {
        if (this.namespace)
            return this.namespace.findChildNamespace(this.name) != null;
        else
            return RootNamespace.findChildNamespace(this.name) != null;
    }

    extendTypes : Array<DBType> = null;
    extendTypesId : number = -1;
    getExtendTypesList() : Array<DBType>
    {
        if (this.extendTypes)
        {
            if (this.extendTypesId == DirtyTypeCacheId)
                return this.extendTypes;
        }

        this.extendTypes = [ this ];
        this.extendTypesId = DirtyTypeCacheId;
        let checkIndex = 0;
        while (checkIndex < this.extendTypes.length)
        {
            let checkType = this.extendTypes[checkIndex];

            if (checkType.supertype)
            {
                let dbsuper = LookupType(checkType.namespace, checkType.supertype);
                if(dbsuper && !this.extendTypes.includes(dbsuper))
                    this.extendTypes.push(dbsuper);
            }

            checkIndex += 1;
        }

        return this.extendTypes;
    }

    formatDelegateSignature(wildcardName : string = null, wildcardType : DBType = null) : string
    {
        let decl : string = "";
        if (this.delegateReturn)
            decl += this.delegateReturn + " ";
        decl += this.name + "(";
        if(this.delegateArgs)
        {
            for(let i = 0; i < this.delegateArgs.length; ++i)
            {
                if (i > 0)
                    decl += ", ";
                if (wildcardName && wildcardType && this.delegateArgs[i].name == wildcardName)
                {
                    decl += this.delegateArgs[i].format(
                        TransferTypeQualifiers(this.delegateArgs[i].typename, wildcardType.name)
                    );
                }
                else
                {
                    decl += this.delegateArgs[i].format();
                }
            }
        }
        decl += ")";
        return decl;
    }

    getProperty(name : string, recurseSuper : boolean = true) : DBProperty | null
    {
        if (!recurseSuper || !this.hasExtendTypes())
        {
            let prop = this.findFirstSymbol(name, DBAllowSymbol.Properties);
            if (prop instanceof DBProperty)
                return prop;
        }
        else
        {
            for (let extendType of this.getExtendTypesList())
            {
                let prop = extendType.findFirstSymbol(name, DBAllowSymbol.Properties);
                if (prop instanceof DBProperty)
                    return prop;
            }
        }

        return null;
    }

    getMethod(name : string, recurseSuper : boolean = true) : DBMethod | null
    {
        if (!recurseSuper || !this.hasExtendTypes())
        {
            let method = this.findFirstSymbol(name, DBAllowSymbol.Functions);
            if (method instanceof DBMethod)
                return method;
        }
        else
        {
            for (let extendType of this.getExtendTypesList())
            {
                let method = extendType.findFirstSymbol(name, DBAllowSymbol.Functions);
                if (method instanceof DBMethod)
                    return method;
            }
        }

        return null;
    }

    getMethodWithIdHint(name : string, id : number, recurseSuper = true) : DBMethod | null
    {
        let fallback : DBMethod = null;

        let method = this.findFirstSymbol(name, DBAllowSymbol.Functions);
        if (method instanceof DBMethod)
        {
            if (method.id == id)
                return method;
            else
                fallback = method;
        }

        if (!recurseSuper)
            return fallback;

        if (!this.hasExtendTypes())
            return fallback;

        for (let extend of this.getExtendTypesList())
        {
            if (extend == this)
                continue;
            let extendMethod = extend.getMethodWithIdHint(name, id, false);
            if (extendMethod)
            {
                if (extendMethod.id == id)
                    return extendMethod;
                else if (!fallback)
                    fallback = extendMethod;
            }
        }

        return fallback;
    }

    inheritsFrom(checktype : string) : boolean
    {
        let it : DBType = this;
        let dbCheck : DBType = LookupType(this.namespace, checktype);
        if(!dbCheck)
            return false;
        let depth = 0;
        while(it && depth < 100)
        {
            if (it == dbCheck)
                return true;

            if (it.supertype)
            {
                it = LookupType(it.namespace, it.supertype);
                depth += 1;
                continue;
            }
            else if (it.unrealsuper)
            {
                it = LookupType(it.namespace, it.unrealsuper);
                depth += 1;
                continue;
            }
            else
            {
                break;
            }
        }
        return false;
    }

    isValueType() : boolean
    {
        if (this.isPrimitive)
            return true;
        if (this.isStruct)
            return true;
        if (this.isEnum)
            return true;
        return false;
    }

    getInheritanceTypes() : Array<DBType>
    {
        let typeList = new Array<DBType>();
        let check : DBType = this;
        while (check && typeList.indexOf(check) == -1)
        {
            typeList.push(check);
            check = LookupType(check.namespace, check.supertype);
        }
        return typeList;
    }

    canOverrideFromParent(methodname : string) : boolean
    {
        // Check script parents
        let checktype = this.supertype;
        let depth = 0;
        while (checktype && depth < 100)
        {
            let dbsuper = LookupType(this.namespace, checktype);
            if (!dbsuper)
                break;
            let method = dbsuper.getMethod(methodname, false);
            if (method)
            {
                if (!dbsuper.isUnrealType() || method.isBlueprintEvent)
                    return true;
            }
            checktype = dbsuper.supertype;
            depth += 1;
        }

        return false;
    }

    forEachSymbol(func : (symbol : DBSymbol) => void, recurseSuper = true)
    {
        if (!recurseSuper || !this.hasExtendTypes())
        {
            for (let [_, syms] of this.symbols)
            {
                if (syms instanceof Array)
                {
                    for (let sym of syms)
                        func(sym);
                }
                else
                {
                    func(syms);
                }
            }
        }
        else
        {
            for (let extendType of this.getExtendTypesList())
            {
                for (let [_, syms] of extendType.symbols)
                {
                    if (syms instanceof Array)
                    {
                        for (let sym of syms)
                            func(sym);
                    }
                    else
                    {
                        func(syms);
                    }
                }
            }
        }
    }

    findFirstSymbol(name : string, allowSymbols = DBAllowSymbol.All) : DBSymbol | null
    {
        for (let type of this.getExtendTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    if (FilterAllowsSymbol(sym, allowSymbols))
                        return sym;
                }
            }
            else
            {
                if (FilterAllowsSymbol(syms, allowSymbols))
                    return syms;
            }
        }

        return null;
    }

    findMethodByUnrealName(unrealName : string) : DBMethod | null
    {
        for (let type of this.getExtendTypesList())
        {
            for (let [name, syms] of type.symbols)
            {
                if (syms instanceof Array)
                {
                    for (let sym of syms)
                    {
                        if (sym instanceof DBMethod)
                        {
                            if (sym.unrealName == unrealName)
                                return sym;
                        }
                    }
                }
                else if (syms instanceof DBMethod)
                {
                    if (syms.unrealName == unrealName)
                        return syms;
                }
            }
        }

        return null;
    }

    // NOTE: Prefix must be at least 2 characters
    findFirstSymbolWithPrefix(prefix : string, allowSymbols = DBAllowSymbol.All, caseSensitive = true, depth = 100) : DBSymbol | null
    {
        if (prefix.length < 2)
            return null;

        let charPrefix = prefix.substring(0, 2).toLowerCase();
        for (let type of this.getExtendTypesList())
        {
            let syms = type.symbolsByPrefix.get(charPrefix);
            if (syms && syms.length != 0)
            {
                for (let sym of syms)
                {
                    if (!FilterAllowsSymbol(sym, allowSymbols))
                        continue;

                    if (caseSensitive)
                    {
                        if (sym.name.startsWith(prefix))
                            return sym;
                    }
                    else
                    {
                        if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                            return sym;
                    }
                }
            }
        }

        return null;
    }

    findSymbols(name : string) : Array<DBSymbol>
    {
        let result : Array<DBSymbol> = [];
        for (let type of this.getExtendTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    result.push(sym);
                }
            }
            else
            {
                result.push(syms);
            }
        }
        return result;
    }

    findFunctionSymbolByParameterCount(name : string, parameterCount : number) : DBMethod | null
    {
        let match : DBMethod = null;
        for (let type of this.getExtendTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    if (sym instanceof DBMethod)
                    {
                        if (!match
                            || sym.args.length == parameterCount
                            || (sym.args.length >= parameterCount && match.args.length < parameterCount)
                            || (sym.args.length >= parameterCount && sym.args.length < match.args.length)
                        )
                        {
                            match = sym;
                        }
                    }
                }
            }
            else
            {
                if (syms instanceof DBMethod)
                {
                    if (!match
                        || syms.args.length == parameterCount
                        || (syms.args.length >= parameterCount && match.args.length < parameterCount)
                        || (syms.args.length >= parameterCount && syms.args.length < match.args.length)
                    )
                    {
                        match = syms;
                    }
                }
            }
        }

        return match;
    }

    addSymbol(symbol : DBSymbol)
    {
        symbol.containingType = this;
        symbol.namespace = this.namespace;

        {
            let syms = this.symbols.get(symbol.name);
            if (!syms)
            {
                this.symbols.set(symbol.name, symbol);
            }
            else if (syms instanceof Array)
            {
                syms.push(symbol);
            }
            else
            {
                this.symbols.set(symbol.name, [symbol, syms]);
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBSymbol>();
                this.symbolsByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(symbol);
        }
    }

    removeSymbol(symbol : DBSymbol)
    {
        {
            let syms = this.symbols.get(symbol.name);
            if (syms)
            {
                if (syms == symbol)
                {
                    this.symbols.delete(symbol.name);
                }
                else if (syms instanceof Array)
                {
                    let index = syms.indexOf(symbol);
                    if (index != -1)
                        syms.splice(index, 1);
                }
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(symbol);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    getBaseMethod(name : string) : DBMethod | null
    {
        let checkSym = this.findFirstSymbol(name, DBAllowSymbol.FunctionsAndMixins);
        let baseFunction = checkSym as DBMethod;
        let checkType : DBType = this;
        while (checkType && checkSym)
        {
            checkType = checkType.getSuperType();
            if (checkType)
            {
                checkSym = checkType.findFirstSymbol(name, DBAllowSymbol.FunctionsAndMixins);
                if (checkSym)
                    baseFunction = checkSym as DBMethod;
            }
            else
            {
                checkSym = null;
            }
        }

        return baseFunction;
    }

    getTypeClassification() : DBTypeClassification
    {
        if (this.classification == DBTypeClassification.Unknown)
        {
            if (this.isDelegate)
                this.classification = DBTypeClassification.Delegate;
            else if (this.isEvent)
                this.classification = DBTypeClassification.Event;
            else if (this.isStruct)
                this.classification = DBTypeClassification.Struct;
            else if (this.isPrimitive)
                this.classification = DBTypeClassification.Primitive;
            else if (this.inheritsFrom("UActorComponent"))
                this.classification = DBTypeClassification.Component;
            else if (this.inheritsFrom("AActor"))
                this.classification = DBTypeClassification.Actor;
            else
                this.classification = DBTypeClassification.Other;
        }
        return this.classification;
    }

    getAccessSpecifier(name : string, create = true) : DBAccessSpecifier | null
    {
        if (this.acccessSpecifiers)
        {
            for (let spec of this.acccessSpecifiers)
            {
                if (spec.name == name)
                    return spec;
            }
        }

        if (create)
        {
            let spec = new DBAccessSpecifier();
            spec.name = name;
            spec.declaredType = this.name;

            if (this.acccessSpecifiers)
                this.acccessSpecifiers.push(spec);
            else
                this.acccessSpecifiers = [spec];

            return spec;
        }

        return null;
    }

    getQualifiedTypenameInNamespace(accessNamespace : DBNamespace) : string
    {
        if (!this.namespace || this.namespace.isRootNamespace())
            return this.name;
        let typename = this.namespace.getQualifiedNamespace() + "::" + this.name;
        if (accessNamespace && !accessNamespace.isRootNamespace())
        {
            let accessPrefix = accessNamespace.getQualifiedNamespace() + "::";
            if (typename.startsWith(accessPrefix))
                typename = typename.substring(accessPrefix.length);
        }
        return typename;
    }
};

export class DBNamespaceDeclaration
{
    declaredModule : string;
    declaredOffset : number;
    declaredOffsetEnd : number;
    scopeOffsetStart : number;
    scopeOffsetEnd : number;
    isNestedParent : boolean = false;
}

export class DBNamespace
{
    name : string = "";
    documentation : string;
    qualifiedNamespace : string | null = null;

    parentNamespace : DBNamespace | null = null;

    childNamespaces = new Map<string, DBNamespace>();
    childNamespacesByPrefix = new Map<string, Array<DBNamespace>>();

    symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
    symbolsByPrefix = new Map<string, Array<DBSymbol>>();

    declarations = new Array<DBNamespaceDeclaration>();

    // Get the full namespace starting at the root
    getQualifiedNamespace() : string
    {
        if (this.qualifiedNamespace !== null)
            return this.qualifiedNamespace;

        this.qualifiedNamespace = this.name;

        let checkParent = this.parentNamespace;
        while (checkParent)
        {
            if (!checkParent.isRootNamespace())
                this.qualifiedNamespace = checkParent.name + "::" +this.qualifiedNamespace;
            checkParent = checkParent.parentNamespace;
        }

        return this.qualifiedNamespace;
    }

    // Whether this namespace shadows a declared type
    isShadowingType() : boolean
    {
        if (!this.parentNamespace)
            return false;
        if (this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types))
            return true;
        return false;
    }

    // Get which type this namespace is shadowing
    getShadowedType() : DBType | null
    {
        if (!this.parentNamespace)
            return null;
        let sym = this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types);
        if (sym instanceof DBType)
            return sym;
        return null;
    }

    isRootNamespace() : boolean
    {
        return this.parentNamespace === null;
    }

    isChildNamespaceOf(parent : DBNamespace) : boolean
    {
        let checkNamespace : DBNamespace = this;
        while (checkNamespace)
        {
            if (checkNamespace == parent)
                return true;
            checkNamespace = checkNamespace.parentNamespace;
        }
        return false;
    }

    forEachSymbol(func : (symbol : DBSymbol) => void)
    {
        for (let [_, syms] of this.symbols)
        {
            if (syms instanceof Array)
            {
                for (let sym of syms)
                    func(sym);
            }
            else
            {
                func(syms);
            }
        }
    }

    findFirstSymbol(name : string, allowSymbols : DBAllowSymbol = DBAllowSymbol.All) : DBSymbol | null
    {
        let syms = this.symbols.get(name);
        if (syms instanceof Array)
        {
            for (let sym of syms)
            {
                if (FilterAllowsSymbol(sym, allowSymbols))
                    return sym;
            }
        }
        else
        {
            if (FilterAllowsSymbol(syms, allowSymbols))
                return syms;
        }

        return null;
    }

    findFirstSymbolWithPrefix(prefix : string, allowSymbols : DBAllowSymbol = DBAllowSymbol.All, caseSensitive = true) : DBSymbol | null
    {
        if (prefix.length < 2)
            return null;

        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let syms = this.symbolsByPrefix.get(charPrefix);
        if (syms && syms.length != 0)
        {
            for (let sym of syms)
            {
                if (!FilterAllowsSymbol(sym, allowSymbols))
                    continue;

                if (caseSensitive)
                {
                    if (sym.name.startsWith(prefix))
                        return sym;
                }
                else
                {
                    if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                        return sym;
                }
            }
        }

        return null;
    }

    findSymbols(name : string, allowSymbol : DBAllowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
    {
        let result : Array<DBSymbol> = [];
        let syms = this.symbols.get(name);
        if (syms instanceof Array)
        {
            for (let sym of syms)
            {
                if (FilterAllowsSymbol(sym, allowSymbol))
                    result.push(sym);
            }
        }
        else
        {
            if (FilterAllowsSymbol(syms, allowSymbol))
                result.push(syms);
        }
        return result;
    }

    findSymbolsWithPrefix(prefix : string, allowSymbols : DBAllowSymbol = DBAllowSymbol.All, caseSensitive = true) : Array<DBSymbol> | null
    {
        if (prefix.length < 2)
            return null;

        let result = [];
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let syms = this.symbolsByPrefix.get(charPrefix);
        if (syms && syms.length != 0)
        {
            for (let sym of syms)
            {
                if (!FilterAllowsSymbol(sym, allowSymbols))
                    continue;

                if (caseSensitive)
                {
                    if (sym.name.startsWith(prefix))
                        result.push(sym);
                }
                else
                {
                    if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                        result.push(sym);
                }
            }
        }

        return result;
    }

    findChildNamespace(name : string) : DBNamespace | null
    {
        let childNamespace = this.childNamespaces.get(name);
        return childNamespace;
    }

    findChildNamespacesWithPrefix(prefix : string, caseSensitive = true) : Array<DBNamespace>
    {
        if (prefix.length < 2)
            return null;

        let result = new Array<DBNamespace>();
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let namespaces = this.childNamespacesByPrefix.get(charPrefix);
        if (namespaces && namespaces.length != 0)
        {
            for (let ns of namespaces)
            {
                if (caseSensitive)
                {
                    if (ns.name.startsWith(prefix))
                        result.push(ns);
                }
                else
                {
                    if (ns.name.toLowerCase().startsWith(prefix.toLowerCase()))
                        result.push(ns);
                }
            }
        }

        return result;
    }

    addSymbol(symbol : DBSymbol)
    {
        symbol.containingType = null;
        symbol.namespace = this;

        {
            let syms = this.symbols.get(symbol.name);
            if (!syms)
            {
                this.symbols.set(symbol.name, symbol);
            }
            else if (syms instanceof Array)
            {
                syms.push(symbol);
            }
            else
            {
                this.symbols.set(symbol.name, [symbol, syms]);
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBSymbol>();
                this.symbolsByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(symbol);
        }
    }

    removeSymbol(symbol : DBSymbol)
    {
        {
            let syms = this.symbols.get(symbol.name);
            if (syms)
            {
                if (syms == symbol)
                {
                    this.symbols.delete(symbol.name);
                }
                else if (syms instanceof Array)
                {
                    let index = syms.indexOf(symbol);
                    if (index != -1)
                        syms.splice(index, 1);
                }
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(symbol);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    addChildNamespace(childNS : DBNamespace)
    {
        childNS.parentNamespace = this;
        this.childNamespaces.set(childNS.name, childNS);
        NamespacesByFullName.set(childNS.getQualifiedNamespace(), childNS);

        if (childNS.name.length > 2)
        {
            let prefix = childNS.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.childNamespacesByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBNamespace>();
                this.childNamespacesByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(childNS);
        }
    }

    removeChildNamespace(childNS : DBNamespace)
    {
        let existingChild = this.childNamespaces.get(childNS.name);
        if (existingChild == childNS)
            this.childNamespaces.delete(childNS.name);

        let existingNS = NamespacesByFullName.get(childNS.getQualifiedNamespace());
        if (existingNS == childNS)
        {
            NamespacesByFullName.delete(childNS.getQualifiedNamespace());
        }

        childNS.parentNamespace = null;
        childNS.qualifiedNamespace = null;

        if (childNS.name.length > 2)
        {
            let prefix = childNS.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.childNamespacesByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(childNS);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    addScriptDeclaration(decl : DBNamespaceDeclaration)
    {
        this.declarations.push(decl);
    }

    removeScriptDeclarations(moduleName : string)
    {
        for (let i = this.declarations.length - 1; i >= 0; --i)
        {
            if (this.declarations[i].declaredModule == moduleName)
                this.declarations.splice(i, 1);
        }
    }

    removeSymbolsDeclaredIn(declaredModule : string, removeSymbols = DBAllowSymbol.All)
    {
        let oldSymbols = this.symbols;

        this.symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
        this.symbolsByPrefix = new Map<string, Array<DBSymbol>>();

        for (let [_, syms] of oldSymbols)
        {
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    if (sym.declaredModule == declaredModule && FilterAllowsSymbol(sym, removeSymbols))
                        continue;
                    this.addSymbol(sym);
                }
            }
            else
            {
                if (syms.declaredModule == declaredModule && FilterAllowsSymbol(syms, removeSymbols))
                    continue;
                this.addSymbol(syms);
            }
        }
    }

    getDeclarationInModule(declaredModule : string) : DBNamespaceDeclaration | null
    {
        for (let decl of this.declarations)
        {
            if (decl.declaredModule == declaredModule)
                return decl;
        }
        return null;
    }

    getFirstScriptDeclaration() : DBNamespaceDeclaration | null
    {
        for (let decl of this.declarations)
        {
            if (decl.declaredModule)
                return decl;
        }
        return null;
    }

    getCppDeclaration() : DBNamespaceDeclaration | null
    {
        for (let decl of this.declarations)
        {
            if (decl.declaredModule === null)
                return decl;
        }
        return null;
    }
};


export class DBAccessSpecifier
{
    name : string;
    declaredType : string;
    isDeclared : boolean = false;

    isPrivate : boolean = false;
    isProtected : boolean = false;

    bAnyReadOnly : boolean = false;
    bAnyEditDefaults : boolean = false;

    permissions : Array<DBAccessPermission>;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    getAccess(fromType : DBType, fromFunction : DBMethod) : [boolean, boolean, boolean]
    {
        if (fromType == null && fromFunction == null)
            return [this.bAnyReadOnly, false, this.bAnyEditDefaults];

        if (fromType)
        {
            if (this.isProtected)
            {
                if (fromType.inheritsFrom(this.declaredType))
                    return [true, true, true];
            }
            else
            {
                if (fromType.name == this.declaredType)
                    return [true, true, true];
            }
        }

        let read = false;
        let write = false;
        let edit = false;

        if (this.bAnyEditDefaults)
            edit = true;
        if (this.bAnyReadOnly)
            read = true;

        if (this.permissions)
        {
            for (let cls of this.permissions)
            {
                let clsApplies = false;

                if (fromType)
                {
                    if (cls.bInherited)
                        clsApplies = fromType.inheritsFrom(cls.accessName);
                    else
                        clsApplies = (fromType.name == cls.accessName);
                }
                else if (fromFunction)
                {
                    clsApplies = (fromFunction.name == cls.accessName);
                }

                if (clsApplies)
                {
                    if (cls.bReadOnly)
                    {
                        read = true;

                        if (cls.bEditDefaults)
                            edit = true;
                    }
                    else
                    {
                        if (cls.bEditDefaults)
                        {
                            edit = true;
                        }
                        else
                        {
                            read = true;
                            edit = true;
                            write = true;
                        }
                    }
                }
            }
        }

        return [read, write, edit];
    }
};

export class DBAccessPermission
{
    accessName : string;
    bInherited : boolean = false;
    bReadOnly : boolean = false;
    bEditDefaults : boolean = false;
};

let DirtyTypeCacheId = 0;
export function OnDirtyTypeCaches()
{
    DirtyTypeCacheId++;
}

let UnrealTypesLoaded = false;
let RootNamespace = new DBNamespace;
let TypesById = new Map<number, DBType>();
let NamespacesByFullName = new Map<string, DBNamespace>([["", RootNamespace]]);
let TypesByName = new Map<string, DBType | Array<DBType>>();

let NextMethodId = 1;
let NextTypeId = 1;

export function CleanTypeName(typename : string) : string
{
    if (typename.startsWith("const "))
        typename = typename.substring(6);
    if (typename.endsWith("&"))
        typename = typename.substring(0, typename.length-1);
    else if (typename.endsWith("&out"))
        typename = typename.substring(0, typename.length-4);
    else if (typename.endsWith("&in"))
        typename = typename.substring(0, typename.length-3);
    else if (typename.endsWith("&inout"))
        typename = typename.substring(0, typename.length-6);
    else if (typename.endsWith("@"))
        typename = typename.substring(0, typename.length-1);
    return typename;
}

export function TypenameEquals(left : string, right : string) : boolean
{
    return CleanTypeName(left) == CleanTypeName(right);
}

export function TransferTypeQualifiers(typename : string, newtype : string) : string
{
    if (typename.startsWith("const "))
        newtype = "const "+newtype;
    if (typename.endsWith("&"))
        newtype = newtype+"&";
    else if (typename.endsWith("&out"))
        newtype = newtype+"&out";
    else if (typename.endsWith("&in"))
        newtype = newtype+"&in";
    else if (typename.endsWith("&inout"))
        newtype = newtype+"&inout";
    return newtype;
}

let re_template = /([A-Za-z_0-9]+)\<(([A-Za-z_0-9:]+\s*(<[A-Za-z_0-9,:\s]+>)?,?)+)\>/;
export function ReplaceTemplateType(typename : string, templateTypes : Array<string>, actualTypes : Array<string>)
{
    let cleanType = CleanTypeName(typename);
    for (let i = 0; i < templateTypes.length; ++i)
    {
        if (cleanType == templateTypes[i])
        {
            return TransferTypeQualifiers(typename, actualTypes[i]);
        }
    }

    if (cleanType.indexOf('<') != -1)
    {
        // Replace the template types inside the subtemplate as well
        let match = cleanType.match(re_template);
        if (match != null)
        {
            let basetype = match[1];

            let newtype = "";
            for (let subtype of match[2].split(","))
            {
                subtype = subtype.trim();
                let templIndex = templateTypes.indexOf(subtype);
                if (templIndex != -1)
                    subtype = actualTypes[templIndex];
                if (newtype.length != 0)
                    newtype += ",";
                newtype += subtype;
            }

            return TransferTypeQualifiers(typename, basetype+"<"+newtype+">");
        }
    }

    return typename;
}

export function GetTypeByName(typename : string) : DBType | null
{
    let found = TypesByName.get(typename);
    if (found instanceof Array)
        return found[0];
    else
        return found;
}

export function GetTypeById(typeid : number) : DBType | null
{
    return TypesById.get(typeid);
}

export function GetAllTypesById() : Map<number, DBType>
{
    return TypesById;
}

export function GetAllNamespaces() : Map<string, DBNamespace>
{
    return NamespacesByFullName;
}

function SplitNamespace(identifier : string) : Array<string>
{
    return identifier.split("::");
}

export function LookupNamespace(namespace : DBNamespace, name : string) : DBNamespace | null
{
    if (!namespace)
        namespace = RootNamespace;

    if (!name || name.length == 0)
        return namespace;

    let namespaceIndex = name.indexOf("::");
    if (namespaceIndex == -1)
    {
        let checkNamespace = namespace;
        while (checkNamespace)
        {
            let targetNamespace = checkNamespace.findChildNamespace(name);
            if (targetNamespace)
                return targetNamespace;

            checkNamespace = checkNamespace.parentNamespace;
        }

        return null;
    }

    if (namespaceIndex == 0)
    {
        namespace = RootNamespace;
        name = name.substring(2);
    }

    let nameParts = SplitNamespace(name);
    let checkNamespace = namespace;

    while (checkNamespace)
    {
        let targetNamespace = checkNamespace;
        for (let part of nameParts)
        {
            targetNamespace = targetNamespace.findChildNamespace(part.trim());
            if (!targetNamespace)
                break;
        }
        if (targetNamespace)
            return targetNamespace;

        checkNamespace = checkNamespace.parentNamespace;
    }
}

export function LookupNamespacesWithPrefix(namespace : DBNamespace, prefix : string, caseSensitive = true) : Array<DBNamespace> | null
{
    if (!namespace)
        namespace = RootNamespace;

    if (!prefix || prefix.length < 2)
        return null;

    let checkNamespace = namespace;
    let result : Array<DBNamespace> = null;
    while (checkNamespace)
    {
        let children = checkNamespace.findChildNamespacesWithPrefix(prefix);
        if (children)
        {
            if (result)
                result = result.concat(children);
            else
                result = children;
        }

        checkNamespace = checkNamespace.parentNamespace;
    }

    return result;
}

export function GetRootNamespace() : DBNamespace
{
    return RootNamespace;
}

export function DeclareNamespace(namespace : DBNamespace, name : string, decl : DBNamespaceDeclaration) : DBNamespace
{
    if (!namespace)
        namespace = RootNamespace;

    let ns = namespace.findChildNamespace(name);
    if (!ns)
    {
        ns = new DBNamespace();
        ns.name = name;
        ns.parentNamespace = RootNamespace;

        namespace.addChildNamespace(ns);
    }

    ns.addScriptDeclaration(decl);
    return ns;
}

export function RemoveNamespaceDeclaration(namespace : DBNamespace, moduleName : string)
{
    namespace.removeScriptDeclarations(moduleName);
    if (namespace.declarations.length == 0 && namespace.parentNamespace)
        namespace.parentNamespace.removeChildNamespace(namespace);
}

export function LookupType(namespace : DBNamespace, typename : string) : DBType | null
{
    if (!typename)
        return null;
    let identifier = CleanTypeName(typename);

    let namespaceIndex = identifier.indexOf("::");
    if (namespaceIndex == -1)
    {
        let found = TypesByName.get(identifier);
        if (found instanceof Array)
            found = found[0];

        if (found)
        {
            if (!namespace || !found.namespace || namespace == found.namespace || namespace.isChildNamespaceOf(found.namespace))
                return found;
        }
    }
    else
    {
        if (!namespace)
            namespace = RootNamespace;

        if (namespaceIndex == 0)
        {
            namespace = RootNamespace;
            identifier = identifier.substring(2);
        }

        let nameParts = SplitNamespace(identifier);
        let finalIdentifier = nameParts[nameParts.length - 1];

        let checkNamespace = namespace;
        while (checkNamespace)
        {
            let targetNamespace = checkNamespace;
            for (let i = 0, count = nameParts.length - 1; i < count; ++i)
            {
                targetNamespace = targetNamespace.findChildNamespace(nameParts[i].trim());
                if (!targetNamespace)
                    break;
            }
            if (targetNamespace)
            {
                let type = targetNamespace.findFirstSymbol(finalIdentifier, DBAllowSymbol.Types);
                if (type instanceof DBType)
                    return type;
            }

            checkNamespace = checkNamespace.parentNamespace;
        }
    }

    // See if we have to create a template instance
    if (identifier.indexOf('<') != -1)
    {
        let match = identifier.match(re_template);
        if (match != null)
        {
            let basetype = match[1];
            let subtypes = match[2].split(",").map(
                function(s : string) : string
                {
                    return s.trim();
                });

            let dbbasetype = LookupType(namespace, basetype);
            if (!dbbasetype || !dbbasetype.isTemplateType())
                return null;

            let inst = dbbasetype.createTemplateInstance(subtypes);
            if (!inst)
                return null;
            inst.name = identifier;
            if (!inst)
                return null;

            AddTypeToDatabase(namespace, inst);
            return inst;
        }
    }

    return null;
}

export function LookupGlobalSymbol(namespace : DBNamespace, name : string, allowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
{
    if (!name)
        return [];

    let identifier = name;
    if (!namespace)
        namespace = RootNamespace;

    let result : Array<DBSymbol> = null;
    let namespaceIndex = identifier.indexOf("::");
    if (namespaceIndex == -1)
    {
        let checkNamespace = namespace;
        while (checkNamespace)
        {
            let symbols = checkNamespace.findSymbols(identifier, allowSymbol);
            if (symbols)
            {
                if (result)
                    result = result.concat(symbols);
                else
                    result = symbols;
            }

            checkNamespace = checkNamespace.parentNamespace;
        }

        return result;
    }

    if (namespaceIndex == 0)
    {
        namespace = RootNamespace;
        identifier = identifier.substring(2);
    }

    let nameParts = SplitNamespace(identifier);
    let finalIdentifier = nameParts[nameParts.length - 1];

    let checkNamespace = namespace;
    while (checkNamespace)
    {
        let targetNamespace = checkNamespace;
        for (let i = 0, count = nameParts.length - 1; i < count; ++i)
        {
            targetNamespace = targetNamespace.findChildNamespace(nameParts[i].trim());
            if (!targetNamespace)
                break;
        }
        if (targetNamespace)
        {
            let symbols = targetNamespace.findSymbols(finalIdentifier, allowSymbol);
            if (symbols)
            {
                if (result)
                    result = result.concat(symbols);
                else
                    result = symbols;
            }
        }

        checkNamespace = checkNamespace.parentNamespace;
    }

    return result;
}

export function LookupGlobalSymbolsWithPrefix(namespace : DBNamespace, prefix : string, allowSymbol = DBAllowSymbol.All, caseSensitive = true) : Array<DBSymbol>
{
    if (!prefix || prefix.length < 2)
        return [];

    if (!namespace)
        namespace = RootNamespace;

    if (!namespace)
        namespace = RootNamespace;

    let result : Array<DBSymbol> = null;
    let checkNamespace = namespace;
    while (checkNamespace)
    {
        let symbols = checkNamespace.findSymbolsWithPrefix(prefix, allowSymbol, caseSensitive);
        if (symbols)
        {
            if (result)
                result = result.concat(symbols);
            else
                result = symbols;
        }

        checkNamespace = checkNamespace.parentNamespace;
    }

    return result;
}

export function HasTypeWithPrefix(namespace : DBNamespace, typenamePrefix : string, caseSensitive = true) : boolean
{
    if (!typenamePrefix || typenamePrefix.length < 2)
        return true;

    if (!namespace)
        namespace = RootNamespace;

    let checkNamespace = namespace;
    while (checkNamespace)
    {
        let symbols = checkNamespace.findSymbolsWithPrefix(typenamePrefix, DBAllowSymbol.Types, caseSensitive);
        if (symbols && symbols.length != 0)
            return true;

        checkNamespace = checkNamespace.parentNamespace;
    }

    return false;
}

export function IsPrimitive(typename : string) : boolean
{
    let type = LookupType(null, typename);
    if (!type)
        return false;
    return type.isPrimitive;
}

function GetTypenameCharPrefix(typename : string) : string
{
    if (typename.length < 2)
        return null;
    return typename.substring(0, 2).toLowerCase();
}

let DatabaseFloatIsFloat64 = false;
let PrimitiveAliases = new Map<string, string>();

export function AddPrimitiveTypes(floatIsFloat64 : boolean)
{
    DatabaseFloatIsFloat64 = floatIsFloat64;

    PrimitiveAliases.clear();
    PrimitiveAliases.set("int", "int32");
    PrimitiveAliases.set("int32", "int32");
    PrimitiveAliases.set("int64", "int64");
    PrimitiveAliases.set("uint", "uint32");
    PrimitiveAliases.set("uint32", "uint32");
    PrimitiveAliases.set("uint64", "uint64");
    PrimitiveAliases.set("int8", "int8");
    PrimitiveAliases.set("uint8", "uint8");
    PrimitiveAliases.set("int16", "int16");
    PrimitiveAliases.set("uint16", "uint16");
    PrimitiveAliases.set("bool", "bool");

    if (DatabaseFloatIsFloat64)
        PrimitiveAliases.set("float", "float64");
    else
        PrimitiveAliases.set("float", "float32");

    PrimitiveAliases.set("float32", "float32");
    PrimitiveAliases.set("float64", "float64");
    PrimitiveAliases.set("double", "float64");

    for (let [primtype, alias] of PrimitiveAliases)
    {
        let dbtype = new DBType().initEmpty(primtype);
        dbtype.isPrimitive = true;
        AddUnrealTypeToDatabase(null, dbtype);
    }
}

export function ArePrimitiveTypesEquivalent(typenameA : string, typenameB : string) : boolean
{
    let aliasA = PrimitiveAliases.get(typenameA);
    let aliasB = PrimitiveAliases.get(typenameB);
    return (aliasA && aliasB && aliasA == aliasB);
}

export function IsPrimitiveFloatType(typename : string) : boolean
{
    let realType = PrimitiveAliases.get(typename);
    return realType == "float32" || realType == "float64";
}

export function AddTypesFromUnreal(input : any)
{
    for (let key in input)
    {
        let type = new DBType();
        type.fromJSON(key, input[key]);

        if (type.name.startsWith("__"))
        {
            if (type.isEnum)
            {
                type.name = type.name.substring(2);
                AddUnrealTypeToDatabase(null, type);
            }
            else
            {
                let decl = new DBNamespaceDeclaration();
                decl.declaredModule = null;

                let ns = LookupNamespace(null, type.name.substring(2));
                if (!ns)
                {
                    ns = DeclareNamespace(null, type.name.substring(2), decl);
                }
                else
                {
                    ns.removeSymbolsDeclaredIn(null, ~DBAllowSymbol.Types);
                    ns.removeScriptDeclarations(null);
                    ns.addScriptDeclaration(decl);
                }

                for (let [name, sym] of type.symbols)
                {
                    if (sym instanceof Array)
                    {
                        for (let symElem of sym)
                            ns.addSymbol(symElem);
                    }
                    else
                        ns.addSymbol(sym);
                }
            }
        }
        else
        {
            AddUnrealTypeToDatabase(null, type);
        }
    }
}

export function HasTypesFromUnreal() : boolean
{
    return UnrealTypesLoaded;
}

export function FinishTypesFromUnreal()
{
    UnrealTypesLoaded = true;

    // Some hardcoded extra information we want to add to unreal functions
    let systemLib = RootNamespace.findChildNamespace("System");
    if (systemLib)
    {
        for (let functionName of [
            "SetTimer", "ClearTimer", "PauseTimer", "UnPauseTimer",
            "IsTimerActive", "IsTimerPaused", "TimerExists",
            "GetTimerElapsedTime", "GetTimerRemainingTime"
        ])
        {
            let timerFunc = systemLib.findFirstSymbol(functionName, DBAllowSymbol.Functions);
            if (timerFunc instanceof DBMethod)
            {
                timerFunc.isDelegateBindFunction = true;
                timerFunc.delegateBindType = "FTimerDynamicDelegate";
                timerFunc.delegateObjectParam = 0;
                timerFunc.delegateFunctionParam = 1;
            }
        }
    }

    // Annotate linear color creation functions
    let linearColorConstructors = RootNamespace.findSymbols("FLinearColor", DBAllowSymbol.Functions);
    for (let method of linearColorConstructors)
    {
        if (method instanceof DBMethod)
            method.methodAnnotation = DBMethodAnnotation.IsLinearColor;
    }

    let linearColorNS = RootNamespace.findChildNamespace("FLinearColor");
    if (linearColorNS)
    {
        let fromHexFunction = linearColorNS.findFirstSymbol("MakeFromHex", DBAllowSymbol.Functions);
        if (fromHexFunction instanceof DBMethod)
            fromHexFunction.methodAnnotation = DBMethodAnnotation.IsHexColor;
    }
}

export function AddTypeToDatabase(namespace : DBNamespace, dbtype : DBType)
{
    if (!namespace)
        namespace = RootNamespace;

    dbtype.namespace = namespace;
    dbtype.typeid = NextTypeId++;

    namespace.addSymbol(dbtype);
    TypesById.set(dbtype.typeid, dbtype);

    let found = TypesByName.get(dbtype.name);
    if (!found)
        TypesByName.set(dbtype.name, dbtype);
    else if (found instanceof Array)
        found.splice(0, 0, dbtype);
    else
        TypesByName.set(dbtype.name, [dbtype, found]);

    OnDirtyTypeCaches();
}

export function AddUnrealTypeToDatabase(namespace : DBNamespace, dbtype : DBType)
{
    if (!namespace)
        namespace = RootNamespace;

    let existingTypes = namespace.findSymbols(dbtype.name, DBAllowSymbol.Types);
    for (let previousType of existingTypes)
    {
        if (previousType instanceof DBType)
        {
            if (!previousType.declaredModule)
                RemoveTypeFromDatabase(previousType);
        }
    }

    AddTypeToDatabase(namespace, dbtype);
}

export function RemoveTypeFromDatabase(dbtype : DBType)
{
    if (!dbtype.namespace)
        return;

    dbtype.namespace.removeSymbol(dbtype);
    dbtype.namespace = null;

    TypesById.delete(dbtype.typeid);

    let found = TypesByName.get(dbtype.name);
    if (found == dbtype)
    {
        TypesByName.delete(dbtype.name);
    }
    else if (found instanceof Array)
    {
        let index = found.indexOf(dbtype);
        if (index != -1)
        {
            found.splice(index, 1);
            if (found.length == 1)
                TypesByName.set(dbtype.name, found[0]);
            else if (found.length == 0)
                TypesByName.delete(dbtype.name);
        }
    }

    OnDirtyTypeCaches();
}

let re_comment_star_start = /^[ \t]*\*+([ \t]|\r?\n)/gi;
let re_comment_star_end = /[\r\n]+[ \t]*\*+[ \t]*/gi;
export function FormatDocumentationComment(doc : string) : string
{
    doc = doc.replace(re_comment_star_end, "\n");
    doc = doc.replace(re_comment_star_start, " ");
    doc = doc.trim();
    return doc;
}
