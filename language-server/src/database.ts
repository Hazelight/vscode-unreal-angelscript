export enum DBAllowSymbol
{
    PropertiesAndFunctions,
    PropertyOnly,
    FunctionOnly,
    FunctionsAndMixins,
};

export enum DBTypeClassification
{
    Unknown,
    Other,
    Component,
    Actor,
    Struct,
    Event,
    Delegate,
    Primitive
};

export function AllowsFunctions(Type : DBAllowSymbol)
{
    return Type != DBAllowSymbol.PropertyOnly;
}

export function AllowsProperties(Type : DBAllowSymbol)
{
    return Type != DBAllowSymbol.FunctionOnly && Type != DBAllowSymbol.FunctionsAndMixins;
}

export interface DBSymbol
{
    name : string;
    containingType : DBType;
    keywords : Array<string>;
    declaredModule : string | null;
};

export class DBProperty implements DBSymbol
{
    name : string;
    typename : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isNoEdit : boolean = false;
    isEditOnly : boolean = false;
    isAutoGenerated : boolean = false;

    accessSpecifier : DBAccessSpecifier = null;
    declaredModule : string | null;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    containingType : DBType = null;
    keywords : Array<string> = null;

    isUProperty : boolean = false;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    fromJSON(name : string, input : any)
    {
        this.name = name;
        this.typename = input[0];
        this.isProtected = false;
        this.isPrivate = false;
        this.isNoEdit = false;
        this.isEditOnly = false;

        if (input.length >= 3)
        {
            if (input[1] == 'NoEdit')
                this.isNoEdit = true;
            else if (input[1] == 'EditOnly')
                this.isEditOnly = true;

            this.documentation = FormatDocumentationComment(input[2]);
        }
        else if (input.length >= 2)
        {
            if (input[1] == 'NoEdit')
                this.isNoEdit = true;
            else if (input[1] == 'EditOnly')
                this.isEditOnly = true;
            else if (!input[1].startsWith("+"))
                this.documentation = FormatDocumentationComment(input[1]);
        }
    }

    format(prefix : string = null) : string
    {
        let str : string = "";
        if (this.isProtected)
            str += "protected ";
        if (this.isPrivate)
            str += "private ";
        str += this.typename;
        str += " ";
        if (prefix)
            str += prefix;
        str += this.name;
        return str;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBProperty
    {
        let inst = new DBProperty();
        inst.name = this.name;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export class DBArg
{
    name : string | null;
    typename : string;
    defaultvalue : string | null;

    init(typename : string, name : string, defaultvalue : string = "") : DBArg
    {
        this.name = name;
        this.typename = typename;
        if (defaultvalue)
            this.defaultvalue = defaultvalue;
        return this;
    }

    fromJSON(input : any)
    {
        this.name = 'name' in input ? input['name'] : null;
        this.typename = input['type'];
        this.defaultvalue = 'default' in input ? input['default'] : null;
    }

    format() : string
    {
        let decl = this.typename;
        if (this.name != null)
            decl += " " + this.name;
        if (this.defaultvalue != null)
            decl += " = " + this.defaultvalue;
        return decl;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBArg
    {
        let inst = new DBArg();
        inst.name = this.name;
        inst.defaultvalue = this.defaultvalue;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export class DBMethod implements DBSymbol
{
    name : string;
    returnType : string;
    args : Array<DBArg>;
    argumentStr : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isConstructor : boolean = false;
    isEvent : boolean = false;
    isConst : boolean = false;
    isFinal : boolean = false;
    isProperty : boolean = false;
    isOverride : boolean = false;
    isDefaultsOnly : boolean = false;
    id : number = NextMethodId++;
    containingType : DBType = null;
    keywords : Array<string> = null;
    isAutoGenerated : boolean = false;
    isMixin : boolean = false;
    accessSpecifier : DBAccessSpecifier = null;

    isUFunction : boolean = false;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    hasSuperCall : boolean = false;
    isEmpty : boolean = false;

    isDelegateBindFunction : boolean = false;
    delegateBindType : string = null;
    delegateObjectParam : number = -1;
    delegateFunctionParam : number = -1;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBMethod
    {
        let inst = new DBMethod();
        inst.name = this.name;
        inst.returnType = ReplaceTemplateType(this.returnType, templateTypes, actualTypes);
        inst.argumentStr = this.argumentStr;
        inst.documentation = this.documentation;
        inst.isProtected = this.isProtected;
        inst.isPrivate = this.isPrivate;
        inst.isConstructor = this.isConstructor;
        inst.isEvent = this.isEvent;
        inst.isConst = this.isConst;
        inst.isProperty = this.isProperty;
        inst.isDefaultsOnly = this.isDefaultsOnly;

        inst.args = [];
        for(let argval of this.args)
            inst.args.push(argval.createTemplateInstance(templateTypes, actualTypes));
        return inst;
    }

    fromJSON(input : any)
    {
        this.name = input.name;

        if ('return' in input)
            this.returnType = input['return'];
        else
            this.returnType = 'void';

        this.args = new Array<DBArg>();
        if ('args' in input)
        {
            for (let argDesc of input['args'])
            {
                let arg = new DBArg;
                arg.fromJSON(argDesc);

                this.args.push(arg);
            }
        }

        if ('doc' in input)
            this.documentation = FormatDocumentationComment(input['doc']);
        else
            this.documentation = null;

        if ('isConstructor' in input)
            this.isConstructor = input['isConstructor'];
        else
            this.isConstructor = false;

        if ('const' in input)
            this.isConst = input['const'];
        else
            this.isConst = false;

        if ('event' in input)
            this.isEvent = input['event'];
        else
            this.isEvent = false;

        if ('isProperty' in input)
            this.isProperty = input['isProperty'];
        else
            this.isProperty = true;

        if ('defaultsonly' in input)
            this.isDefaultsOnly = input['defaultsonly'];

        if ('keywords' in input)
            this.keywords = input['keywords'];

        if ('meta' in input)
        {
            if (!this.macroMeta)
                this.macroMeta = new Map<string, string>();
            for (let metaSpec in input['meta'])
                this.macroMeta.set(metaSpec.toLowerCase(), input['meta'][metaSpec]);
            this.cacheDelegateMeta();
        }
    }

    cacheDelegateMeta()
    {
        if (!this.macroMeta)
            return;

        if (this.macroMeta.has("delegatefunctionparam")
            && this.macroMeta.has("delegateobjectparam")
            && this.macroMeta.has("delegatebindtype"))
        {
            this.isDelegateBindFunction = true;
            this.delegateBindType = this.macroMeta.get("delegatebindtype");

            let functionParam = this.macroMeta.get("delegatefunctionparam");
            let objectParam = this.macroMeta.get("delegateobjectparam");

            for (let i = 0, count = this.args.length; i < count; ++i)
            {
                if (this.args[i].name == objectParam)
                    this.delegateObjectParam = i;
                else if (this.args[i].name == functionParam)
                    this.delegateFunctionParam = i;
            }

        }
    }

    format(prefix : string = null, skipFirstArg = false, skipReturn = false, replaceName : string = null) : string
    {
        let decl : string = "";
        if (!skipReturn)
            decl += this.returnType + " ";
        if(prefix != null)
            decl += prefix;
        if (replaceName)
            decl += replaceName + "(";
        else
            decl += this.name + "(";
        let firstArg = true;
        if (this.argumentStr)
        {
            let argStr = this.argumentStr;
            if (skipFirstArg)
            {
                let cPos = argStr.search(",");
                if(cPos != -1)
                    argStr = argStr.substr(cPos+1).trim();
                else
                    argStr = "";
            }
            decl += argStr;
        }
        else if(this.args)
        {
            for(let i = 0; i < this.args.length; ++i)
            {
                if (skipFirstArg && i == 0)
                    continue;

                if (i > 0 || (skipFirstArg && i > 1))
                    decl += ", ";
                decl += this.args[i].format();
            }
        }
        decl += ")";
        if (this.isConst)
            decl += " const";
        if (this.isProperty && this.declaredModule)
            decl += " property";
        return decl;
    }

    // Get documentation either from this function or from the
    // first parent function we're overriding
    findAvailableDocumentation(includeParent = true, includeType = true) : string
    {
        if (this.documentation)
            return this.documentation;
        // Use the parent function's documentation
        if (this.containingType && includeParent)
        {
            for (let checktype of this.containingType.getInheritanceTypes())
            {
                let parentFunc = checktype.findFirstSymbol(this.name, DBAllowSymbol.FunctionOnly);
                if (parentFunc && parentFunc instanceof DBMethod && parentFunc.documentation)
                    return parentFunc.documentation;
            }
        }
        // Use the type's documentation for constructors
        if (this.isConstructor && includeType)
        {
            let dbReturn = GetType(this.returnType);
            if (dbReturn && dbReturn.documentation)
                return dbReturn.documentation;
        }
        return null;
    }

    hasMetaData(meta : string) : boolean
    {
        if (!this.macroMeta)
            return false;
        return this.macroMeta.has(meta.toLowerCase());
    }

    getRequiredArgumentCount() : number
    {
        if (!this.args)
            return 0;
        for (let i = 0, argCount = this.args.length; i < argCount; ++i)
        {
            if (this.args[i].defaultvalue)
                return i;
        }
        return this.args.length;
    }

    isSignatureEqual(otherFunc : DBMethod) : boolean
    {
        if ((!!this.args) != (!!otherFunc.args))
            return false;

        if (this.args)
        {
            if (this.args.length != otherFunc.args.length)
                return false;
            for (let i = 0, argCount = this.args.length; i < argCount; ++i)
            {
                if (this.args[i].typename != otherFunc.args[i].typename)
                    return false;
            }
        }

        if (this.returnType != otherFunc.returnType)
            return false;

        return true;
    }
};

export class DBType
{
    typename : string;
    supertype : string;
    properties : Array<DBProperty>;
    methods : Array<DBMethod>;
    unrealsuper : string;
    documentation : string;

    isStruct : boolean;
    isNS : boolean;
    isEnum : boolean;
    rawName : string;
    namespaceResolved : boolean;
    shadowedNamespace : boolean;
    isDelegate : boolean = false;
    isEvent : boolean = false;
    isPrimitive : boolean = false;
    isGlobalScope : boolean = false;
    isTemplateInstantiation : boolean = false;

    classification : DBTypeClassification = DBTypeClassification.Unknown;
    acccessSpecifiers : Array<DBAccessSpecifier> = null;

    keywords : Array<string> = null;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    delegateArgs : Array<DBArg> = null;
    delegateReturn : string = null;

    declaredModule : string;
    multipleModules : boolean = false;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    siblingTypes : Array<string>;
    subTypes : Array<string>;

    symbols: Map<string, Array<DBSymbol>> = new Map<string, Array<DBSymbol>>();
    symbolsByPrefix: Map<string, Array<DBSymbol>> = new Map<string, Array<DBSymbol>>();

    createTemplateInstance(actualTypes : Array<string>) : DBType
    {
        if (actualTypes.length != this.subTypes.length)
            return null;

        let inst = new DBType();
        inst.typename = this.typename;
        inst.supertype = this.supertype;
        inst.isNS = this.isNS;
        inst.isEnum = this.isEnum;
        inst.rawName = this.rawName;
        inst.namespaceResolved = this.namespaceResolved;
        inst.shadowedNamespace = this.shadowedNamespace;
        inst.multipleModules = this.multipleModules;
        inst.declaredModule = this.declaredModule;
        inst.moduleOffset = this.moduleOffset;
        inst.moduleOffsetEnd = this.moduleOffsetEnd;
        inst.isTemplateInstantiation = true;
        if(this.siblingTypes)
            inst.siblingTypes = this.siblingTypes.slice();
        inst.subTypes = null;

        inst.properties = [];
        for (let prop of this.properties)
        {
            let newProp = prop.createTemplateInstance(this.subTypes, actualTypes);
            inst.properties.push(newProp);
            inst.addSymbol(newProp);
        }

        inst.methods = [];
        for (let mth of this.methods)
        {
            let newMethod = mth.createTemplateInstance(this.subTypes, actualTypes);
            inst.methods.push(newMethod);
            inst.addSymbol(newMethod);
        }

        return inst;
    }

    initEmpty(name : string) : DBType
    {
        this.typename = name;
        this.methods = new Array<DBMethod>();
        this.properties = new Array<DBProperty>();
        return this;
    }

    fromJSON(name : string, input : any)
    {
        this.typename = name;
        this.isGlobalScope = (name == "__");
        this.properties = new Array<DBProperty>();
        for (let key in input.properties)
        {
            let prop = new DBProperty();
            prop.fromJSON(key, input.properties[key]);
            this.properties.push(prop);
            this.addSymbol(prop);
        }
        this.methods = new Array<DBMethod>();
        for (let key in input.methods)
        {
            let func = new DBMethod();
            func.fromJSON(input.methods[key]);
            this.methods.push(func);
            this.addSymbol(func);
        }

        if ('subtypes' in input)
        {
            this.subTypes = new Array<string>();
            for(let subtype of input['subtypes'])
            {
                this.subTypes.push(subtype);
            }
        }

        if ('supertype' in input)
        {
            this.unrealsuper = input['supertype'];
        }

        if ('inherits' in input)
        {
            this.supertype = input['inherits'];
        }

        if ('doc' in input)
            this.documentation = FormatDocumentationComment(input['doc']);
        else
            this.documentation = null;

        if ('keywords' in input)
            this.keywords = input['keywords'];

        if ('isStruct' in input)
            this.isStruct = input['isStruct'];
        else
            this.isStruct = false;

        if ('isEnum' in input)
            this.isEnum = input['isEnum'];
        else
            this.isEnum = false;

        let delegateSignatureMethod : DBSymbol = null;
        if ('isEvent' in input)
        {
            this.isEvent = input['isEvent'];
            if (this.isEvent)
                delegateSignatureMethod = this.findFirstSymbol("Broadcast");
        }
        else
        {
            delegateSignatureMethod = this.findFirstSymbol("Broadcast");
            this.isEvent = delegateSignatureMethod != null;
        }

        if ('isDelegate' in input)
        {
            this.isDelegate = input['isDelegate'];
            if (this.isDelegate)
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
        }
        else
        {
            if (!this.isEvent)
            {
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
                this.isDelegate = delegateSignatureMethod != null;
            }
            else
            {
                this.isDelegate = false;
            }
        }

        if (delegateSignatureMethod != null && delegateSignatureMethod instanceof DBMethod)
        {
            // Detect the signature for the delegate from the Broadcast or ExecuteIfBound methods
            this.delegateArgs = delegateSignatureMethod.args;
            this.delegateReturn = delegateSignatureMethod.returnType;

            // Mark the Add/Bind/Unbind functions so diagnostics can see them
            let bindFuncs: DBSymbol[] = [];
            if (this.isEvent)
                bindFuncs = [this.findFirstSymbol("AddUFunction"), this.findFirstSymbol("Unbind")];
            else
                bindFuncs = [this.findFirstSymbol("BindUFunction")];

            bindFuncs.forEach((bindFunc: DBSymbol) => {
                if (bindFunc instanceof DBMethod)
                {
                    bindFunc.isDelegateBindFunction = true;
                    bindFunc.delegateBindType = this.typename;
                    bindFunc.delegateObjectParam = 0;
                    bindFunc.delegateFunctionParam = 1;
                }
            });
        }
    }

    resolveNamespace()
    {
        this.isNS = this.typename.startsWith("__");
        this.namespaceResolved = true;

        if (this.isNS)
        {
            let otherType = this.typename.substring(2);
            this.shadowedNamespace = database.get(otherType) != null;
            this.rawName = otherType;
        }
    }

    getDisplayName() : string
    {
        if (!this.namespaceResolved)
            this.resolveNamespace();
        if(this.isNS)
            return this.rawName;
        return this.typename;
    }

    isNamespace() : boolean
    {
        if (!this.namespaceResolved)
            this.resolveNamespace();
        return this.isNS;
    }

    isNamespaceOrGlobalScope() : boolean
    {
        if (this.isGlobalScope)
            return true;
        return this.isNamespace();
    }

    isTemplateType() : boolean
    {
        return this.subTypes && this.subTypes.length != 0;
    }

    isShadowedNamespace() : boolean
    {
        if (!this.namespaceResolved)
            this.resolveNamespace();
        return this.isNS && this.shadowedNamespace;
    }

    equalsTypename(typename : string) : boolean
    {
        if (!this.namespaceResolved)
            this.resolveNamespace();
        if (typename == this.typename)
            return true;
        if (this.isNS && typename == this.rawName)
            return true;
        let cleaned = CleanTypeName(typename);
        if (cleaned == this.typename)
            return true;
        if (this.isNS && cleaned == this.rawName)
            return true;
        return false;
    }

    isUnrealType() : boolean
    {
        return !this.declaredModule;
    }

    hasExtendTypes() : boolean
    {
        if(this.supertype)
            return true;
        if(this.siblingTypes)
            return true;
        return false;
    }

    getExtendTypes() : Array<DBType>
    {
        let extend : Array<DBType> = [];
        if (this.supertype)
        {
            let dbsuper = GetType(this.supertype);
            if(dbsuper)
                extend.push(dbsuper);
        }

        if (this.siblingTypes)
        {
            for (let sibling of this.siblingTypes)
            {
                let dbsibling = GetType(sibling);
                if(dbsibling)
                    extend.push(dbsibling);
            }
        }

        return extend;
    }


    combineTypes : Array<DBType> = null;
    combineTypesId : number = -1;
    getCombineTypesList() : Array<DBType>
    {
        if (this.combineTypes)
        {
            if (this.combineTypesId == DirtyTypeCacheId)
                return this.combineTypes;
        }

        this.combineTypes = [ this ];
        this.combineTypesId = DirtyTypeCacheId;
        let checkIndex = 0;
        while (checkIndex < this.combineTypes.length)
        {
            let checkType = this.combineTypes[checkIndex];

            if (checkType.supertype)
            {
                let dbsuper = GetType(checkType.supertype);
                if(dbsuper && !this.combineTypes.includes(dbsuper))
                    this.combineTypes.push(dbsuper);
            }

            if (checkType.siblingTypes)
            {
                for (let sibling of checkType.siblingTypes)
                {
                    let dbsibling = GetType(sibling);
                    if(dbsibling && !this.combineTypes.includes(dbsibling))
                        this.combineTypes.push(dbsibling);
                }
            }

            checkIndex += 1;
        }

        return this.combineTypes;
    }

    allProperties() : Array<DBProperty>
    {
        if (!this.hasExtendTypes())
            return this.properties;

        let props : Array<DBProperty> = [];
        for(let extend of this.getCombineTypesList())
            props = props.concat(extend.properties);
        return props;
    }

    formatDelegateSignature() : string
    {
        let decl : string = "";
        if (this.delegateReturn)
            decl += this.delegateReturn + " ";
        decl += this.typename + "(";
        if(this.delegateArgs)
        {
            for(let i = 0; i < this.delegateArgs.length; ++i)
            {
                if (i > 0)
                    decl += ", ";
                decl += this.delegateArgs[i].format();
            }
        }
        decl += ")";
        return decl;
    }

    getProperty(name : string, recurse : boolean = true) : DBProperty | null
    {
        for (let prop of this.properties)
        {
            if (prop.name == name)
            {
                return prop;
            }
        }

        if (!recurse)
            return null;

        if (!this.hasExtendTypes())
            return null;

        for(let extend of this.getCombineTypesList())
        {
            let prop = extend.getProperty(name, false);
            if(prop)
                return prop;
        }

        return null;
    }

    getPropertyAccessorType(name : string) : string | null
    {
        let getter = this.getMethod("Get"+name);
        if (getter)
            return getter.returnType;
        let setter = this.getMethod("Get"+name);
        if (setter && setter.args.length >= 1)
            return setter.args[0].typename;
        return null;
    }

    allMethods() : Array<DBMethod>
    {
        if (!this.hasExtendTypes())
            return this.methods;

        let methodNames = new Map<string, DBType>();
        let outMethods = new Array<DBMethod>();

        for (let type of this.getCombineTypesList())
        {
            for (let mth of type.methods)
            {
                let declType = methodNames.get(mth.name);
                if (declType && declType != type)
                    continue;

                outMethods.push(mth);
                methodNames.set(mth.name, type);
            }
        }

        return outMethods;
    }

    getMethod(name : string, recurse : boolean = true) : DBMethod | null
    {
        for (let func of this.methods)
        {
            if (func.name == name)
            {
                return func;
            }
        }

        if (!recurse)
            return null;

        if (!this.hasExtendTypes())
            return null;

        for(let extend of this.getCombineTypesList())
        {
            let mth = extend.getMethod(name, false);
            if(mth)
                return mth;
        }

        return null;
    }

    getMethodWithIdHint(name : string, idHint : number, recurse : boolean = true) : DBMethod | null
    {
        let fallback : DBMethod = null;
        for (let func of this.methods)
        {
            if (func.name == name)
            {
                if (func.id == idHint)
                    return func;
                else if (!fallback)
                    fallback = func;
            }
        }

        if (!recurse)
            return fallback;

        if (!this.hasExtendTypes())
            return fallback;

        for(let extend of this.getCombineTypesList())
        {
            let mth = extend.getMethodWithIdHint(name, idHint, false);
            if (mth)
            {
                if (mth.id == idHint)
                    return mth;
                else if (!fallback)
                    fallback = mth;
            }
        }

        return fallback;
    }

    inheritsFrom(checktype : string) : boolean
    {
        let it : DBType = this;
        let dbCheck : DBType = GetType(checktype);
        if(!dbCheck)
            return false;
        let depth = 0;
        while(it && depth < 100)
        {
            if (it == dbCheck)
                return true;

            if (it.supertype)
            {
                it = GetType(it.supertype);
                depth += 1;
                continue;
            }
            else if (it.unrealsuper)
            {
                it = GetType(it.unrealsuper);
                depth += 1;
                continue;
            }
            else
            {
                break;
            }
        }
        return false;
    }

    isValueType() : boolean
    {
        if (this.isPrimitive)
            return true;
        if (this.isStruct)
            return true;
        if (this.isEnum)
            return true;
        return false;
    }

    getInheritanceTypes() : Array<DBType>
    {
        let typeList = new Array<DBType>();
        let check : DBType = this;
        while (check && typeList.indexOf(check) == -1)
        {
            typeList.push(check);
            check = GetType(check.supertype);
        }
        return typeList;
    }

    canOverrideFromParent(methodname : string) : boolean
    {
        // Check script parents
        let checktype = this.supertype;
        let depth = 0;
        while (checktype && depth < 100)
        {
            let dbsuper = GetType(checktype);
            if (!dbsuper)
                break;
            let method = dbsuper.getMethod(methodname, false);
            if (method)
            {
                if (!dbsuper.isUnrealType || method.isEvent)
                    return true;
            }
            checktype = dbsuper.supertype;
            depth += 1;
        }

        return false;
    }

    hasOverriddenMethod(methodname : string) : boolean
    {
        for (let func of this.methods)
        {
            if (func.name == methodname)
                return true;
        }
        return false;
    }

    findFirstSymbol(name : string, allow_symbols = DBAllowSymbol.PropertiesAndFunctions) : DBSymbol | null
    {
        for (let type of this.getCombineTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms && syms.length != 0)
            {
                for (let sym of syms)
                {
                    if (sym instanceof DBProperty)
                    {
                        if (allow_symbols == DBAllowSymbol.FunctionOnly)
                            continue;
                        if (allow_symbols == DBAllowSymbol.FunctionsAndMixins)
                            continue;
                        return sym;
                    }
                    else if (sym instanceof DBMethod)
                    {
                        if (allow_symbols == DBAllowSymbol.PropertyOnly)
                            continue;
                        if (sym.isMixin && allow_symbols != DBAllowSymbol.FunctionsAndMixins)
                            continue;
                        return sym;
                    }
                }
            }
        }

        return null;
    }

    // NOTE: Prefix must be at least 2 characters
    findFirstSymbolWithPrefix(prefix : string, allow_symbols = DBAllowSymbol.PropertiesAndFunctions, caseSensitive = true, depth = 100) : DBSymbol | null
    {
        if (prefix.length < 2)
            return null;

        let charPrefix = prefix.substr(0, 2).toLowerCase();
        for (let type of this.getCombineTypesList())
        {
            let syms = type.symbolsByPrefix.get(charPrefix);
            if (syms && syms.length != 0)
            {
                for (let sym of syms)
                {
                    if (sym instanceof DBProperty)
                    {
                        if (allow_symbols == DBAllowSymbol.FunctionOnly)
                            continue;
                        if (allow_symbols == DBAllowSymbol.FunctionsAndMixins)
                            continue;
                    }
                    else if (sym instanceof DBMethod)
                    {
                        if (allow_symbols == DBAllowSymbol.PropertyOnly)
                            continue;
                        if (sym.isMixin && allow_symbols != DBAllowSymbol.FunctionsAndMixins)
                            continue;
                    }

                    if (caseSensitive)
                    {
                        if (sym.name.startsWith(prefix))
                            return sym;
                    }
                    else
                    {
                        if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                            return sym;
                    }
                }
            }
        }

        return null;
    }

    findSymbols(name : string) : Array<DBSymbol>
    {
        let result : Array<DBSymbol> = [];
        this.findSymbolsInternal(result, name);
        return result;
    }

    private findSymbolsInternal(result : Array<DBSymbol>, name : string)
    {
        for (let type of this.getCombineTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms)
            {
                for (let sym of syms)
                    result.push(sym);
            }
        }
    }

    addSymbol(symbol : DBSymbol)
    {
        symbol.containingType = this;

        {
            let syms = this.symbols.get(symbol.name);
            if (!syms)
            {
                syms = new Array<DBSymbol>();
                this.symbols.set(symbol.name, syms);
            }

            syms.push(symbol);
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substr(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBSymbol>();
                this.symbolsByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(symbol);
        }
    }

    removeSymbol(symbol : DBSymbol)
    {
        {
            let syms = this.symbols.get(symbol.name);
            if (syms)
            {
                let index = syms.indexOf(symbol);
                if (index != -1)
                    syms.splice(index, 1);
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substr(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(symbol);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    getTypeClassification() : DBTypeClassification
    {
        if (this.classification == DBTypeClassification.Unknown)
        {
            if (this.isDelegate)
                this.classification = DBTypeClassification.Delegate;
            else if (this.isEvent)
                this.classification = DBTypeClassification.Event;
            else if (this.isStruct)
                this.classification = DBTypeClassification.Struct;
            else if (this.isPrimitive)
                this.classification = DBTypeClassification.Primitive;
            else if (this.inheritsFrom("UActorComponent"))
                this.classification = DBTypeClassification.Component;
            else if (this.inheritsFrom("AActor"))
                this.classification = DBTypeClassification.Actor;
            else
                this.classification = DBTypeClassification.Other;
        }
        return this.classification;
    }

    getAccessSpecifier(name : string, create = true) : DBAccessSpecifier | null
    {
        if (this.acccessSpecifiers)
        {
            for (let spec of this.acccessSpecifiers)
            {
                if (spec.name == name)
                    return spec;
            }
        }

        if (create)
        {
            let spec = new DBAccessSpecifier();
            spec.name = name;
            spec.declaredType = this.typename;

            if (this.acccessSpecifiers)
                this.acccessSpecifiers.push(spec);
            else
                this.acccessSpecifiers = [spec];

            return spec;
        }

        return null;
    }
};

export class DBAccessSpecifier
{
    name : string;
    declaredType : string;
    isDeclared : boolean = false;

    isPrivate : boolean = false;
    isProtected : boolean = false;

    bAnyReadOnly : boolean = false;
    bAnyEditDefaults : boolean = false;

    permissions : Array<DBAccessPermission>;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    getAccess(fromType : DBType, fromFunction : DBMethod) : [boolean, boolean, boolean]
    {
        if (fromType == null && fromFunction == null)
            return [this.bAnyReadOnly, false, this.bAnyEditDefaults];

        if (fromType)
        {
            if (this.isProtected)
            {
                if (fromType.inheritsFrom(this.declaredType))
                    return [true, true, true];
            }
            else
            {
                if (fromType.typename == this.declaredType)
                    return [true, true, true];
            }
        }

        let read = false;
        let write = false;
        let edit = false;

        if (this.bAnyEditDefaults)
            edit = true;
        if (this.bAnyReadOnly)
            read = true;

        if (this.permissions)
        {
            for (let cls of this.permissions)
            {
                let clsApplies = false;

                if (fromType)
                {
                    if (cls.bInherited)
                        clsApplies = fromType.inheritsFrom(cls.accessName);
                    else
                        clsApplies = (fromType.typename == cls.accessName);
                }
                else if (fromFunction)
                {
                    clsApplies = (fromFunction.name == cls.accessName);
                }

                if (clsApplies)
                {
                    if (cls.bReadOnly)
                    {
                        read = true;

                        if (cls.bEditDefaults)
                            edit = true;
                    }
                    else
                    {
                        if (cls.bEditDefaults)
                        {
                            edit = true;
                        }
                        else
                        {
                            read = true;
                            edit = true;
                            write = true;
                        }
                    }
                }
            }
        }

        return [read, write, edit];
    }
};

export class DBAccessPermission
{
    accessName : string;
    bInherited : boolean = false;
    bReadOnly : boolean = false;
    bEditDefaults : boolean = false;
};

export let DirtyTypeCacheId = 0;
export function OnDirtyTypeCaches()
{
    DirtyTypeCacheId++;
}

export let database = new Map<string, DBType>();
export let databaseByPrefix = new Map<string, Array<DBType>>();
export let databaseScriptTypes = new Map<string, Array<DBType>>();
export let UnrealTypesLoaded = false;
let NextMethodId = 0;

export let ScriptGlobals = new Map<string, Array<DBSymbol>>();
export let ScriptGlobalsByPrefix = new Map<string, Array<DBSymbol>>();

export function FindScriptGlobalSymbols(funcName : string) : Array<DBSymbol>
{
    return ScriptGlobals.get(funcName);
}

export function FindScriptGlobalSymbolsWithPrefix(prefix : string, caseSensitive = true) : Array<DBSymbol>
{
    if (prefix.length < 2)
        return null;

    let charPrefix = prefix.substr(0, 2).toLowerCase();
    let syms = ScriptGlobalsByPrefix.get(charPrefix);
    if (syms && syms.length != 0)
    {
        let result = new Array<DBSymbol>();
        for (let sym of syms)
        {
            if (caseSensitive)
            {
                if (sym.name.startsWith(prefix))
                    result.push(sym);
            }
            else
            {
                if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                    result.push(sym);
            }
        }
        return result;
    }

    return null;
}

export function AddScriptGlobalSymbol(symbol : DBSymbol)
{
    let syms = ScriptGlobals.get(symbol.name);
    if (!syms)
    {
        syms = new Array<DBMethod>();
        ScriptGlobals.set(symbol.name, syms);
    }

    syms.push(symbol);

    if (symbol.name.length > 2)
    {
        let prefix = symbol.name.substr(0, 2).toLowerCase();

        let prefixSyms = ScriptGlobalsByPrefix.get(prefix);
        if (!prefixSyms)
        {
            prefixSyms = new Array<DBMethod>();
            ScriptGlobalsByPrefix.set(prefix, prefixSyms);
        }

        prefixSyms.push(symbol);
    }
}

export function RemoveScriptGlobalSymbol(symbol : DBSymbol)
{
    {
        let syms = ScriptGlobals.get(symbol.name);
        if (syms)
        {
            let index = syms.indexOf(symbol);
            if (index != -1)
                syms.splice(index, 1);
        }
    }

    if (symbol.name.length > 2)
    {
        let prefix = symbol.name.substr(0, 2).toLowerCase();
        let prefixSyms = ScriptGlobalsByPrefix.get(prefix);
        if (prefixSyms)
        {
            let index = prefixSyms.indexOf(symbol);
            if (index != -1)
                prefixSyms.splice(index, 1);
        }
    }
}

export function CleanTypeName(typename : string) : string
{
    if (typename.startsWith("const "))
        typename = typename.substring(6);
    if (typename.endsWith("&"))
        typename = typename.substring(0, typename.length-1);
    else if (typename.endsWith("&out"))
        typename = typename.substring(0, typename.length-4);
    else if (typename.endsWith("&in"))
        typename = typename.substring(0, typename.length-3);
    else if (typename.endsWith("&inout"))
        typename = typename.substring(0, typename.length-6);
    else if (typename.endsWith("@"))
        typename = typename.substring(0, typename.length-1);
    return typename;
}

export function TypenameEquals(left : string, right : string) : boolean
{
    return CleanTypeName(left) == CleanTypeName(right);
}

export function TransferTypeQualifiers(typename : string, newtype : string) : string
{
    if (typename.startsWith("const "))
        newtype = "const "+newtype;
    if (typename.endsWith("&"))
        newtype = newtype+"&";
    else if (typename.endsWith("&out"))
        newtype = newtype+"&out";
    else if (typename.endsWith("&in"))
        newtype = newtype+"&in";
    else if (typename.endsWith("&inout"))
        newtype = newtype+"&inout";
    return newtype;
}

let re_template = /([A-Za-z_0-9]+)\<(([A-Za-z_0-9]+\s*(<[A-Za-z_0-9,\s]+>)?,?)+)\>/;
export function ReplaceTemplateType(typename : string, templateTypes : Array<string>, actualTypes : Array<string>)
{
    typename = CleanTypeName(typename);
    for (let i = 0; i < templateTypes.length; ++i)
    {
        if (typename == templateTypes[i])
        {
            return actualTypes[i];
        }
    }

    if (typename.indexOf('<') != -1)
    {
        // Replace the template types inside the subtemplate as well
        let match = typename.match(re_template);
        if (match != null)
        {
            let basetype = match[1];

            let newtype = "";
            for (let subtype of match[2].split(","))
            {
                subtype = subtype.trim();
                let templIndex = templateTypes.indexOf(subtype);
                if (templIndex != -1)
                    subtype = actualTypes[templIndex];
                if (newtype.length != 0)
                    newtype += ",";
                newtype += subtype;
            }

            return basetype+"<"+newtype+">";
        }
    }

    return typename;
}

export function GetType(typename : string) : DBType | null
{
    if (!typename)
        return null;
    typename = CleanTypeName(typename);
    let foundType = database.get(typename);
    if (foundType)
        return foundType;

    let enumType = database.get("__"+typename)
    if (enumType && enumType.isEnum)
        return enumType;

    if (typename.indexOf('<') != -1)
    {
        // See if we can create a template instance
        let match = typename.match(re_template);
        if (match != null)
        {
            let basetype = match[1];
            let subtypes = match[2].split(",").map(
                function(s : string) : string
                {
                    return s.trim();
                });

            let dbbasetype = GetType(basetype);
            if (!dbbasetype)
                return null;

            let inst = dbbasetype.createTemplateInstance(subtypes);
            if (!inst)
                return null;
            inst.typename = typename;
            if (!inst)
                return null;

            AddTypeToDatabase(inst);
            return inst;
        }
    }

    return null;
}

export function IsPrimitive(typename : string) : boolean
{
    let type = GetType(typename);
    if (!type)
        return false;
    return type.isPrimitive;
}

function GetTypenameCharPrefix(typename : string) : string
{
    if (typename.length < 2)
        return null;
    if (typename.startsWith("__"))
    {
        if (typename.length < 4)
            return null;
        return typename.substr(2, 2).toLowerCase();
    }
    else
    {
        return typename.substr(0, 2).toLowerCase();
    }
}

export function HasTypeWithPrefix(typenamePrefix : string, caseSensitive = true) : boolean
{
    let charPrefix = GetTypenameCharPrefix(typenamePrefix);
    if (!charPrefix)
        return true;

    let syms = databaseByPrefix.get(charPrefix);
    if (syms && syms.length != 0)
    {
        for (let type of syms)
        {
            if (caseSensitive)
            {
                if (type.typename.startsWith(typenamePrefix))
                    return true;
                if (type.isEnum && type.typename.startsWith("__"+typenamePrefix))
                    return true;
            }
            else
            {
                if (type.typename.toLowerCase().startsWith(typenamePrefix.toLowerCase()))
                    return true;
                if (type.isEnum && type.typename.toLowerCase().startsWith("__"+typenamePrefix.toLowerCase()))
                    return true;
            }
        }
    }

    return false;
}

export function AddPrimitiveTypes()
{
    for (let primtype of [
        "int",
        "uint",
        "int8",
        "uint8",
        "int16",
        "uint16",
        "int32",
        "uint32",
        "int64",
        "uint64",
        "float",
        "double",
        "bool",
    ])
    {
        let dbtype = new DBType().initEmpty(primtype);
        dbtype.isPrimitive = true;
        AddTypeToDatabase(dbtype);
    }
}

export function AddTypesFromUnreal(input : any)
{
    for (let key in input)
    {
        let type = new DBType();
        type.fromJSON(key, input[key]);

        if (type.isNamespace())
            MergeNamespaceToDB(type);
        else
            AddTypeToDatabase(type);
    }
}

export function HasTypesFromUnreal() : boolean
{
    return UnrealTypesLoaded;
}

export function FinishTypesFromUnreal()
{
    UnrealTypesLoaded = true;

    // Some hardcoded extra information we want to add to unreal functions
    let systemLib = GetType("__System");
    if (systemLib)
    {
        for (let functionName of [
            "SetTimer", "ClearTimer", "PauseTimer", "UnPauseTimer",
            "IsTimerActive", "IsTimerPaused", "TimerExists",
            "GetTimerElapsedTime", "GetTimerRemainingTime"
        ])
        {
            let timerFunc = systemLib.getMethod(functionName);
            if (timerFunc)
            {
                timerFunc.isDelegateBindFunction = true;
                timerFunc.delegateBindType = "FTimerDynamicDelegate";
                timerFunc.delegateObjectParam = 0;
                timerFunc.delegateFunctionParam = 1;
            }
        }
    }
}

export function AddTypeToDatabase(dbtype : DBType)
{
    let prefix = GetTypenameCharPrefix(dbtype.typename);
    if (prefix)
    {
        let prefixSyms = databaseByPrefix.get(prefix);
        if (!prefixSyms)
        {
            prefixSyms = new Array<DBType>();
            databaseByPrefix.set(prefix, prefixSyms);
        }

        let previousType = database.get(dbtype.typename);
        if (previousType)
        {
            let previousIndex = prefixSyms.indexOf(previousType);
            if (previousIndex != -1)
                prefixSyms.splice(previousIndex, 1);
        }

        prefixSyms.push(dbtype);
    }

    if (dbtype.declaredModule)
    {
        let scriptTypes = databaseScriptTypes.get(dbtype.typename);
        if (scriptTypes)
        {
            for (let i = scriptTypes.length-1; i >= 0; --i)
            {
                if (scriptTypes[i].declaredModule == dbtype.declaredModule)
                    scriptTypes.splice(i, 1);
            }
            scriptTypes.push(dbtype);
        }
        else
        {
            databaseScriptTypes.set(dbtype.typename, [dbtype]);
        }
    }

    database.set(dbtype.typename, dbtype);
    OnDirtyTypeCaches();
}

export function RemoveTypeFromDatabase(dbtype : DBType)
{
    let wasPrimaryForName = false;
    if (database.get(dbtype.typename) == dbtype)
    {
        database.delete(dbtype.typename);
        wasPrimaryForName = true;
    }

    let prefix = GetTypenameCharPrefix(dbtype.typename);
    if (prefix)
    {
        let prefixSyms = databaseByPrefix.get(prefix);
        if (prefixSyms)
        {
            let previousIndex = prefixSyms.indexOf(dbtype);
            if (previousIndex != -1)
                prefixSyms.splice(previousIndex, 1);
        }
    }

    if (dbtype.declaredModule)
    {
        let scriptTypes = databaseScriptTypes.get(dbtype.typename);
        if (scriptTypes)
        {
            for (let i = scriptTypes.length-1; i >= 0; --i)
            {
                if (scriptTypes[i] == dbtype)
                    scriptTypes.splice(i, 1);
            }

            if (scriptTypes.length != 0)
            {
                if (wasPrimaryForName)
                {
                    // Revert to the script type that had this name previously
                    let prevType = scriptTypes[scriptTypes.length-1];
                    scriptTypes.splice(scriptTypes.length-1, 1);
                    AddTypeToDatabase(prevType);
                }
            }
            else
            {
                databaseScriptTypes.delete(dbtype.typename);
            }
        }
    }

    OnDirtyTypeCaches();
}

export function GetAllTypes() : Map<string, DBType>
{
    return database;
}

let re_comment_star_start = /^[ \t]*\*+([ \t]|\r?\n)/gi;
let re_comment_star_end = /[\r\n]+[ \t]*\*+[ \t]*/gi;
export function FormatDocumentationComment(doc : string) : string
{
    doc = doc.replace(re_comment_star_end, "\n");
    doc = doc.replace(re_comment_star_start, " ");
    doc = doc.trim();
    return doc;
}

export function RemoveTypesInModule(module : string)
{
    for (let [name, dbtype] of database)
    {
        if (dbtype.declaredModule == module)
            database.delete(name);
    }
}

export function RemoveModuleFromNamespace(namespace : string, modulename : string)
{
    // Check if we already have a database entry for this namespace
    let dbtype = database.get(namespace);
    if (!dbtype)
        return;
    if (dbtype.declaredModule == modulename && !dbtype.multipleModules)
    {
        database.delete(namespace);
        return;
    }

    // Remove old methods from the same module that we are replacing
    let keepMethods : Array<DBMethod> = [];
    let removeMethods : Array<DBMethod> = [];
    for (let method of dbtype.methods)
    {
        if (method.declaredModule != modulename)
            keepMethods.push(method);
        else
            removeMethods.push(method);
    }

    // Remove symbols for old methods
    for (let method of removeMethods)
        dbtype.removeSymbol(method);

    // Remove old properties from the same module that we are replacing
    let keepProperties : Array<DBProperty> = [];
    let removeProperties : Array<DBProperty> = [];
    for (let prop of dbtype.properties)
    {
        if (prop.declaredModule != modulename)
            keepProperties.push(prop);
        else
            removeProperties.push(prop);
    }

    // Remove symbols for old properties
    for (let prop of removeProperties)
        dbtype.removeSymbol(prop);

    // Replace lists in type
    dbtype.methods = keepMethods;
    dbtype.properties = keepProperties;
}

export function MergeNamespaceToDB(newtype : DBType, removeOldSymbols : boolean = true) : DBType
{
    // Check if we already have a database entry for this namespace
    let dbtype = database.get(newtype.typename);
    if (!dbtype || (dbtype.declaredModule == newtype.declaredModule && removeOldSymbols && !dbtype.multipleModules))
    {
        AddTypeToDatabase(newtype);
        return newtype;
    }

    // Remove old methods from the same module that we are replacing
    let keepMethods : Array<DBMethod> = [];
    let removeMethods : Array<DBMethod> = [];
    if (removeOldSymbols)
    {
        for (let method of dbtype.methods)
        {
            if (method.declaredModule != newtype.declaredModule)
                keepMethods.push(method);
            else
                removeMethods.push(method);
        }
    }
    else
    {
        // Keep all methods
        keepMethods = dbtype.methods;
    }

    // Add all the new methods we're adding
    for (let method of newtype.methods)
    {
        keepMethods.push(method);
        dbtype.addSymbol(method);
    }

    // Replace method list in type
    dbtype.methods = keepMethods;

    // Remove symbols for old methods
    for (let method of removeMethods)
        dbtype.removeSymbol(method);

    // Remove old properties from the same module that we are replacing
    let keepProperties : Array<DBProperty> = [];
    let removeProperties : Array<DBProperty> = [];
    if (removeOldSymbols)
    {
        for (let prop of dbtype.properties)
        {
            if (prop.declaredModule != newtype.declaredModule)
                keepProperties.push(prop);
            else
                removeProperties.push(prop);
        }
    }
    else
    {
        // Keep all methods
        keepProperties = dbtype.properties;
    }

    // Add all the new methods we're adding
    for (let prop of newtype.properties)
    {
        keepProperties.push(prop);
        dbtype.addSymbol(prop);
    }

    // Replace method list in type
    dbtype.properties = keepProperties;

    // Remove symbols for old methods
    for (let prop of removeProperties)
        dbtype.removeSymbol(prop);

    // Now that we're merging methods this type is no longer exclusive to this module
    if (dbtype.declaredModule != newtype.declaredModule)
    {
        dbtype.declaredModule = null;
        dbtype.multipleModules = true;
    }

    return dbtype;
}